{"instruction": "Write a Csound instrument that creates a week sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from week10_3.orc and week10_3.sco\n; Original files preserved in same directory\n\nsr        =         44100\nkr        =         4410\nksmps     =         10\nnchnls    =         1\n\n\n          instr 1\n \naindex    phasor    (.894/1.5)/p3,p6         ; OFFSET PASSED IN p6 (BETWEEN 0 AND 1)\nasig      table     aindex*32768,1           ; READ TABLE 1 (WITH RAW VALUES) \n          out       asig                     ; OUTPUT \n\n          endin\n\n</CsInstruments>\n<CsScore>\nf1 0 65536 -1 \"hellorcb.aif\" 0 4 0  ; GEN-01 STATEMENT (ACCESSES 2 SEC FILE \"TSE-U\")\n\n\n;       st      dur     \n\ni1     0         2        \n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a fts sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from fts.orc and fts.sco\n; Original files preserved in same directory\n\nsr \t\t= \t\t44100\nkr \t\t= \t\t44100\nksmps \t= \t\t1\nnchnls\t=\t\t1\n\n\n\n\t\tinstr 1\n\na1 \t\t= \t\t2\n\t\tout \t\ta1\n\t\tendin\n\n</CsInstruments>\n<CsScore>\nf1 0 1024 -20 1 2000\nf2 0 1024 20 2 100\nf3 0 1024 -20 3 2\nf4 0 1024 20 4\nf5 0 1024 -20 5 45\nf6 0 1024 20 6\nf7 0 1024 20 7 1 10\n;f8 0 1024 20 8 1\n;f9 0 1024 20 9 1\n\ni1 0 2\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a comb sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from comb3.orc and comb3.sco\n; Original files preserved in same directory\n\nsr        =         44100\nkr        =         4410\nksmps     =         10\nnchnls    =         1\n\n\n        instr 1\na1      soundin 5\na2      comb        a1*p4*.5, p5, p6, 0\n        out     a2\n        endin\n\n</CsInstruments>\n<CsScore>\n; Score to accompany:\n\n;p1  p2   p3   p4   p5   p6\n;i   time dur  amp  rvt  loopt\ni1   0    .5   1    0    .008\ni1   +    .    .37  <    .\ni1   .    .    .32  <    .\ni1   .    .    .32  <    .\ni1   .    .    .3   4    .\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a week sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from week10_2.orc and Week10_2.sco\n; Original files preserved in same directory\n\nsr        =         44100\nkr        =         4410\nksmps     =         10\nnchnls    =         1\n\n\n          instr 1\n \naindex    line      0,p3,1                   ; RISES FROM 0 TO 1 IN THE TOTAL DURATION\nasig      table     aindex*32768,1           ; READ TABLE 1 (WITH RAW VALUES) \n          out       asig                     ; OUTPUT \n                                   \n          endin\n\n</CsInstruments>\n<CsScore>\nf1 0 65536 -1 \"hellorcb.aif\" 0 4 0  ; GEN-01 STATEMENT (ACCESSES 2 SEC FILE \"TSE-U\")\n\n\n;       st      dur     \n\ni1     0        1\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a interpolator sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from Interpolator.orc and Interpolator.sco\n; Original files preserved in same directory\n\nsr     = 44100\nkr     = 441\nksmps  = 100\nnchnls = 1\n\n\ninstr    1 ; Sample1 interpolator - Set kr to rate wanted\n\nilevl    = p4 ; Output level\n\nain      soundin  \"Piano.aif\"\nkin      downsamp  ain\naout     interp  kin\nout      aout*ilevl\n\nendin\n\n</CsInstruments>\n<CsScore>\n;     Strt  Leng  Levl\ni1    0.00  1.47  1.00\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument for ipi\t\t=\t\t3.14159 using bell sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from BELLFUNC.ORC and BELLFUNC.SCO\n; Original files preserved in same directory\n\nsr\t\t=\t\t1\t\t\t\t\t; N.B. WE'RE NOT GENERATING AUDIO HERE, JUST...\nkr\t\t=\t\t1\t\t\t\t\t; A BUNCH OF VALUES FOR AN ARRAY, SO THE...\nksmps\t=\t\t1\t\t\t\t\t; sr AND kr DON'T REALLY MATTER.  HOWEVER,...\nksmps\t=\t\t1\t\t\t\t\t; IT'S CONVENIENT TO MAKE THEM = 1, SO THAT...\nnchnls\t=\t\t1\t\t\t\t\t; p3 CAN BE USED TO SPECIFY THE NUMBER OF...\n\n; bellfunc.orc\n;\n; Even though csound only provides a limited number of stock gen subroutines,\n; it includes one (gen 1) which can read in an external file.  Hence, you\n; can use a standalone program to generate functions that aren't standard.\n; In fact, as this example shows, you can use csound itself to create them.\n; You just have to remember to perf with the floating point option (-f)...\n;\n; This orchestra will generate a bell-shaped function with max amp of 1.0 --\n; required by endless.orc for an amplitude control function.\n; Say \"perf -f bellfunc.orc bellfunc.sco\" to run it, then rename the output\n; test.sf file to soundin.10 so that endless.sco can read it in via Gen 1.  rp\n;\n\t\t\t\t\t\t\t\t\t; VALUES TO COMPUTE DIRECTLY.\n\n\t\tinstr   1\nipi\t\t=\t\t3.14159\nisize\t=\t\tp3-1\t\t\t\t\t; SINCE sr=1, p3 HAS NUMBER OF LOCS TO GENERATE\nkx\t\tinit\t\t0\n; RISSET'S FORMULA (FROM DODGE):  exp(-4.8283*(1-cos(2*ipi*(kx-1023.5)/2047)))\naval\t\t=\t\texp(-4.8283*(1+cos(2*ipi*kx/isize)))        \nkx\t\t=\t\tkx+1                \n\t\tout\t\taval\n\t\tendin\n\n</CsInstruments>\n<CsScore>\n;score to generate bell function in p3 locations\ni01     0       2048\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a week sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from week10_1.orc and Week10_1.sco\n; Original files preserved in same directory\n\nsr        =         44100\nkr        =         4410\nksmps     =         10\nnchnls    =         1\n\n\n          instr 1\n \naindex    phasor    (.894/1.5)/p3       ; READ THROUGH ONCE IN THE TOTAL DURATION \nasig      table     aindex*32768,1      ; READ TABLE 1 (WITH RAW VALUES) \n          out       asig                ; OUTPUT \n\n          endin\n\n</CsInstruments>\n<CsScore>\nf1 0 65536 -1 \"hellorcb.aif\" 0 4 0  ; GEN-01 STATEMENT (ACCESSES 2 SEC FILE \"TSE-U\")\n\n\n;       st      dur     \n\ni1     0         2\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a slewlimiter sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from SlewLimiter.orc and SlewLimiter.sco\n; Original files preserved in same directory\n\nsr     = 44100\nkr     = 44100\nksmps  = 1\nnchnls = 1\n\n\ninstr    1 ; Slew limiter\n\nilevl    = p4                         ; Output level\nislew1   = p5                         ; Slew rate - start\nislew2   = p6                         ; Slew rate - end\nkout     init 0                       ; Initialise output\n\nain      soundin  \"Sample1\"\n\nkin      downsamp  ain                ; Convert to kr\nkslew    expon  islew1, p3, islew2    ; Generate exponential sweep\nif       kin > (kout + kslew) goto up ; Detect slew up over limit\nif       kin < (kout - kslew) goto dn ; Detect slew down over limit\nkout     = kin                        ; Let pass if below slew limit\ngoto     out                          ; Goto output\nup:\nkout     = kout + kslew               ; Limit slew up\ngoto     out                          ; Goto output\ndn:\nkout     = kout - kslew               ; Limit slew down\ngoto     out                          ; Goto output\nout:\naout     upsamp  kout                 ; Convert to sr\nout      aout*ilevl                   ; Level and output\n\nendin\n\n</CsInstruments>\n<CsScore>\n;   Strt  Leng  Levl  Slew1 Slew2\ni1  0.00  1.47  1.00  32767 1.00\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a week sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from week10_4.orc and week10_4.sco\n; Original files preserved in same directory\n\nsr        =         44100\nkr        =         4410\nksmps     =         10\nnchnls    =         1\n\n\n          instr 1\n\naindex    line      p6,2,p7                  ; READ FROM p6 TO p7 (BETWEEN 0 AND 1) \nasig      table     aindex*32768,1           ; READ TABLE 1 (WITH RAW VALUES) \n          out       asig                     ; OUTPUT \n                              \n          endin\n\n</CsInstruments>\n<CsScore>\nf1 0 65536 -1 \"hellorcb.aif\" 0 4 0  ; GEN-01 STATEMENT (ACCESSES 2 SEC FILE \"TSE-U\")\n\n\n;       st      dur     \n\ni1     0         2\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a sndenv sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from SNDENV.ORC and SNDENV.SCO\n; Original files preserved in same directory\n\nsr        =         44100     ; SAMPLE RATE OF SOUND FILE\nkr        =         4410      ; CONTROL RATE\nksmps     =         10\nnchnls    =         1         ; MONO\n\n\n          instr 1\nk1        expon     p6, p3, p7               ; p6 = START CURVE, p7 = END CURVE\na1        soundin   p5, 0, 4                 ; p5 = SOUNDIN F#\na1        =         a1 * k1                  ; RAMP THE SOUNDIN\nascale    =         a1 * p4                  ; p4 = SCALING FACTOR\n          display   k1, p3                   ; DRAW CURVE ON SCREEN\n          out       ascale                   ; WRITE TO DISK\n          endin\n\n</CsInstruments>\n<CsScore>\n;SoundEnv.sco\n\nf1 0 0 -1 \"asleep.aiff\" 0 4     ; 4 tells its a 16 bit opperation\n\n\n\n;p1     p2      p3      p4          p5          p6              p7\n;ins    start   dur     ampscale    sndfunc     slopestart      slopeend\ni1      0       1       1           1           1               .001\ni1      2       2       1           1           1               .0001\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a xnxn sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from xnxn.orc and xnxn.sco\n; Original files preserved in same directory\n\nsr     = 44100\nkr     = 4410\nksmps  = 10\nnchnls = 1\n\n\ninstr    1 ; x*2 - x^2 function (Even harmonic distortion)\n\nain      soundin  \"Sample1\"\nain      = ain/32767\nafunc    = ain*2 - ain*ain\nout      afunc*32767/3\n\nendin\n\ninstr    2 ; x*3 - x^3 distortion (Compresses Signal)\n\nain      soundin  \"Sample1\"\nain      = ain/32767\nafunc    = ain*3 - ain*ain*ain\nout      afunc*16384\n\nendin\n\n</CsInstruments>\n<CsScore>\n;   Strt  Leng\ni1  0.00  1.47\n\n;   Strt  Leng\ni2  2.00  1.47\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a valve sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from Valve.orc and Valve.sco\n; Original files preserved in same directory\n\nsr     = 44100\nkr     = 4410\nksmps  = 10\nnchnls = 1\n\n\ninstr    1 ; \"Valve\" distortion using variable power\n\nidrive   = p4/100\n\na1       soundin  \"Sample1\"\na2       = a1/2 + 16384\nk0       downsamp  a1\nk1       = (abs(k0)/4096)*idrive + 1\nk2       pow  32767, k1, 32767\na3       pow  a2, k1\nout      (a3/k2 - 16384)*2\n\nendin\n\n</CsInstruments>\n<CsScore>\n;Dist: 0=Clean, 1=Mild Distortion/Enhancement 10=Metal 100=Suicide!\n\n;   Strt  Leng  Dist\ni1  0.00  1.47  1.00\ni1  2.00  .     10.0\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a testone sound using test/demonstration", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from testone1.orc and testone1.sco\n; Original files preserved in same directory\n\nsr        =         44100\nkr        =         4410\nksmps     =         10\nnchnls    =         1\n\n\n          instr 12       \nkph       phasor    100                      ;PHASES 0-1 100 TIMES/SECOND\nilength   =         ftlen(p4)\nkph       =         kph*ilength\na1        table     kph, p4\nk1        downsamp  a1\n          out       a1*20000\n          printks   \"address=%6.4f\\t value=%6.4f\\n\", .01, kph, k1, 0, 0\n          display   a1, .01\n          endin\n\n</CsInstruments>\n<CsScore>\nf1  0   4096    10  1 ;sine\nf2  0   1024    10  1 ;sine\nf3  0   128     10  1 ;sine\nf4  0   16      10  1 ;sine\nf5  0   8       10  1 ;sine\n\ni12   0     1   1\ni12   2     1   2                                \ni12   4     1   3                                \ni12   6     1   4\ni12   8     1   5\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument for Log function distortion using distortion effect", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from LogDistort.orc and LogDistort.sco\n; Original files preserved in same directory\n\nsr     = 44100\nkr     = 4410\nksmps  = 10\nnchnls = 1\n\n\ninstr    1 ; Log function distortion\n\na1       soundin  \"Piano.aif\"\na2       = (a1 + 32767)/16384\na3       = log(a2)\nout      a3*16384\n\nendin\n\n</CsInstruments>\n<CsScore>\n;   Strt  Leng\ni1  0.00  1.47\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a oscilx sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from oscilx.orc and oscilx.sco\n; Original files preserved in same directory\n\nsr\t\t=\t\t44100\nkr\t\t=\t\t4410\nksmps\t=\t\t10\nnchnls\t=\t\t1\n\n\n\t\tinstr 1\na1\t\toscilx\t10000, 1000, 1, 10\n\t\tout\t\ta1\n\t\tendin\n\n</CsInstruments>\n<CsScore>\nf1 0 1024 10 1\n\ni1 0 1\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a parisft sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from parisft.orc and parisft.sco\n; Original files preserved in same directory\n\nsr \t\t= \t\t44100\nkr \t\t= \t\t44100\nksmps \t= \t\t1\nnchnls\t=\t\t1\n\n\n\t\tinstr 1\na1 \t\t= \t\t2\n\t\tout \t\ta1\n\t\tendin\n\n</CsInstruments>\n<CsScore>\nf1 0 1024 -20 1 2000\nf2 0 1024 20 2 100\nf3 0 1024 -20 3 2\nf4 0 1024 20 4\nf5 0 1024 -20 5 45\nf6 0 1024 20 6\nf7 0 1024 20 7 1 2\nf7 0 1024 20 7 1 3\nf7 0 1024 20 7 1 4\nf7 0 1024 20 7 1 5\nf7 0 1024 20 7 1 10\n\ni1 0 2\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a divider sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from Divider.orc and Divider.sco\n; Original files preserved in same directory\n\nsr       = 44100\nkr       = 44100\nksmps    = 1\nnchnls   = 1\n\n\ninstr    1 ; Inverts waveform between alternate zero crossings\n\nilevl    = p4                               ; Output level\nimix     = p5                               ; Mix: 0=Dry 1=Inverted\nkcount   init 1                             ; Initialize counter\n\nain      soundin  \"Sample1\"\n\nktrig    trigger  ain, 0, 0                 ; Detect alternate zero crossings\nif       ktrig = 0 goto out                 ; If no zero cross, skip to output\nif       kcount = 1 goto 2                  ; Flip count 1/2\nkgate1   = 1                                ; Set gate to 1\nkcount   = 1                                ; Set count to 1...\ngoto     out                                ; ...then go to output\n2:\nkgate1   =-1                                ; Set gate to -1\nkcount   = 2                                ; Set count to 2\nout:                                        ; Output section\naout     = ain*(1 - imix) + ain*kgate1*imix ; Gate input signals to splice\nout      aout*ilevl                         ; Level and output\n\nendin\n\n</CsInstruments>\n<CsScore>\n;Mix: 0=Dry 1=Inverted\n\n;     Strt  Leng  Levl  Mix\ni01   0.00  1.50  1.00  0.50\ni01   2.00  .     .     1.00\ne\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a rev sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from rev5.orc and rev5.sco\n; Original files preserved in same directory\n\nsr             =         44100\nkr             =         4410\nksmps          =         10\n\n\n;1 in 1 out\n\n; FILE SKIP IORIG IGAIN REVTIMESTRETCH\ninstr          1\nifile          =         p4\niskip          =         p5\niorig          =         p6\nigain          =         p7\nistretch       =         p8\nirvt1          =         .2*istretch\nirvt2          =         .5*istretch\nirvt3          =         2.1*istretch\nirvt4          =         3.06*istretch\n\nirev           =         1-iorig\n\n     araw      soundin   ifile,iskip\n     araw      =         araw*igain\n     ar1       alpass    araw,irvt1,.04\n     ar2       alpass    ar1,irvt2,.035\n     ar3       alpass    ar2,irvt3,.065\n     ar4       alpass    ar3,irvt4,.0491\n     arl1      tone      ar1,10000\n     arl2      tone      ar2,6000\n     arl3      tone      ar3,3000\n     arl4      tone      ar4,1000\n     arev      =         arl1+arl2+arl3+arl4\n               out       (irev*arev)+(iorig*araw)\nendin\n\n</CsInstruments>\n<CsScore>\ni1 0 8.366735 1 0 .6 1.\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a phasorsample sound using phaser effect and sample playback", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from phasorsample.orc and phasorsample.sco\n; Original files preserved in same directory\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\ninstr 1\n \n aindex line 0, p3, 1               ; RISES FROM 0 TO 1 IN THE TOTAL DURATION\n asig table aindex*32768, 1         ; READ TABLE 1 (WITH RAW VALUES) \n out asig                           ; OUTPUT \n\n\nendin\n\n</CsInstruments>\n<CsScore>\nf1 0 65536 -1 \"hellorcb.aif\" 0 4 0      ;GEN-01 STATEMENT (ACCESSES 2 SEC FILE \"TSE-U\")\n\n\n;       st      dur     \n\ni1     0        1\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a width sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from Width.orc and Width.sco\n; Original files preserved in same directory\n\nsr       = 44100\nkr       = 4410\nksmps    = 10\nnchnls   = 2\n\n\ninstr    1 ; Stereo Width Expander.\n\nilevl    = p4 ; Output level\niwidth   = p5 ; Stereo width: -1=Mono 0=Normal +1=Wide\nifreq    = p6 ; Bass cut frequency\n\na1, a2   soundin  \"StereoSample\"\n\nahp1     atone  a1, ifreq\nahp2     atone  a2, ifreq\naout1    = (iwidth >= 0 ? a1 - ahp2*iwidth : a1 + a2*int(iwidth))\naout2    = (iwidth >= 0 ? a2 - ahp1*iwidth : a2 + a1*int(iwidth))\nouts1    aout1*ilevl\nouts2    aout2*ilevl\n\nendin\n\n</CsInstruments>\n<CsScore>\n;     Strt  Leng  Levl  Width Freq\ni01   0.00  1.50  1.00 -1.00  100 ; Mono\ni01   2.00  .     .    -0.50  .   ; Narrow\ni01   4.00  .     .     0.00  .   ; Normal stereo\ni01   6.00  .     .     0.50  .   ; Wide\ni01   8.00  .     .     1.00  .   ; Very wide\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a tuning sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from tuning1.orc and tuning1.sco\n; Original files preserved in same directory\n\nsr        =         44100\nkr        =         4410\nksmps     =         10\nnchnls    =         1\n\n; tuning.orc  \n; instrument used in \n; Erich Neuwirth \n; Musical Temperaments                                 \n; Springer Verlag\n; ISBN 3-211-83040-5\n; the instrument has the wave shape sin(x)/(const-cos(x))\n; the constant is frequency dependent\n\n\ngilowavf  init      100\ngihiwavf  init      1000\ngiloenvf  init      100\ngihienvf  init      1000\ngilowavv  init      1.03\ngihiwavv  init      1.5\ngiloenvv  init      1.75\ngihienvv  init      1\ngiattime  init      65/1024\ngireltime init      68/1024\ngiattend  init      0.868\ngirelstart init     0.921\ngidecup   init      girelstart-giattend\ngidechump init      0.102\n\n          instr 1             ; sin(t)/(a-cos(t))\n   \niwavlin   =         p5\niwavlin   =         (iwavlin < gilowavf ? gilowavf : iwavlin)\niwavlin   =         (iwavlin > gihiwavf ? gihiwavf : iwavlin)\niwavlin   =         (iwavlin-gilowavf)/(gihiwavf-gilowavf)\niwavlin   =         gilowavv + iwavlin*(gihiwavv-gilowavv)\n      \nienvlin   =         p5\nienvlin   =         (ienvlin < giloenvf ? giloenvf : ienvlin)\nienvlin   =         (ienvlin > gihienvf ? gihienvf : ienvlin)\nienvlin   =         (ienvlin-giloenvf)/(gihienvf-giloenvf)\nienvlin   =         giloenvv + ienvlin*(gihienvv-giloenvv)\n      \n\niwav      =         iwavlin\nienv      =         ienvlin\n   \niwavconst =         exp(log(iwav*iwav-1)/2)\n   \nax        phasor    p5                       ; PHASE FOR WAVE FREQUENCY\nay        phasor    p5,0.25 shifted phase for wave frequency to get cosine\na1        table     ax,1,1                   ; SINE \na2        table     ay,1,1                   ; COSINE\nawav      =         p4*iwavconst*a1/(iwav-a2) ; WAVEFORM STANDARDIZED FOR VOLUME p4 \n                                             \n \nkdur      =         p3\nkx        phasor    1/kdur                   ; ONE CYCLE PER NOTE \nkenvshort table     kx,8,1\n\nkt        =         kdur*kx                  ; TIME FOR WHOLE NOTE\n\nktatt     =         kt/ienv                  ; SLOWER PHASE FOR ATTACK \nkdectime  =         kdur-giattime*ienv-gireltime\nktdec     =         (kt-ienv*giattime)/kdectime\nktdec     =         ( ktdec < 0 ? 0 : ktdec )\nktdec     =         ( ktdec > 1 ? 1 : ktdec )\nktrel     =         kt-kdur+gireltime\n   \n\nkatt      table     ktatt,5,1\n\nkdecfact  =         kdectime/(1-giattime*ienv-gireltime)  \nkdecfact  =         (kdecfact > 1 ? 1 : kdecfact)\nkdec1     table     ktdec,6,1  \nkdec2     =         (kdecfact*ktdec*gidecup)+giattend\nkdec      =         kdec2+kdec1*kdecfact*gidechump\n   \nkrel      table     ktrel,7,1 \nkrel      =         krel*(giattend+gidecup*kdecfact)\n\nkenvlong  =         katt\nkenvlong  =         (kt > ienv*giattime ? kdec : kenvlong)\nkenvlong  =         (kt > kdur - gireltime ? krel : kenvlong)\n   \nkenv      =         (kdectime > 0 ? kenvlong : kenvshort)\n\n          out       kenv*awav\n   \n          endin\n\n</CsInstruments>\n<CsScore>\n;Erich Neuwirth <neuwirth@smc.univie.ac.at>\n;Computer Supported Didactics Working Group, Univ. Vienna\n;Visit our SunSITE at http://sunsite.univie.ac.at\n;tuning.sco                        \n\nf1 0 4096 10 1                     ; use GEN10 to compute a sine wave\nf4 0 1024 7 0 23 0.948 15 1.000 17 0.973 10 0.869 503 1.000 388 0.921 28 0.697 10 0.408 17 0.092 13 0 ; master envelope\nf5 0 1024 7 0 23 0.948 15 1.000 17 0.973 10 0.869 0 0.0 959 0 ; attack\nf6 0 1024 7 0.0  570 1.0 454 0.0  ; decay hump \nf7 0 1024 7 1.0 28 0.757 10 0.443 17 0.010 13 0 956 0 ; release shape\nf8 0 1024 7 0.0 177 0.948 115 1.000 131 0.973 77 0.869 216 0.658 77 0.385 131 0.087 100 0  ; envelope for short notes\n\n\ns\n  i1      0    0.5   8000   264\n  i1      0.5  0.5   8000   330\n  i1      1    0.5   8000   396\n\n  i1      1.5  1   8000   264\n  i1      1.5  1   8000   330\n  i1      1.5  1   8000   396\n\n  i1      2.5  0.5 8000   792\n  i1      3    1   8000   792\n  i1      4    0.5 8000   660\n  i1      4.5  1   8000   660\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a logic sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac Logic_out.aiff\n</CsOptions>\n<CsInstruments>\n\nsr       = 44100\nkr       = 44100\nksmps    = 1\nnchnls   = 2\n\n\ninstr    1 ; AND/NAND gate - Complementary outputs\n\nilevl    = p4                          ; Output level\n\nain1     soundin  \"../scores/samples/apoc.aiff\"\nain2     soundin  \"../scores/samples/female.aiff\"\n\nkin1     downsamp  ain1                ; Convert to kr\nkin2     downsamp  ain2                ; Convert to kr\nk1       = ( kin1 > 0 ? 1 : 0 )        ; See if above zero crossing line\nk2       = ( kin2 > 0 ? 1 : 0 )        ; See if above zero crossing line\nif       k1 + k2 == 2 goto and1        ; If both above, goto and1\ngoto     and2\nand1:\naand     = 1                           ; Set AND gate to 1...\ngoto     out                           ; ...then goto out\nand2:\naand     = 0                           ; Set AND gate to 1\nout:\nouts1    aand*(ain1 + ain2)            ; AND gate signals and output L\nouts2    (1 - aand)*(ain1 + ain2)      ; NAND gate signals and output R\n\nendin\n\ninstr    2 ; Exclusive OR gate - Complementary outputs\n\nilevl    = p4                          ; Output level\n\nain1     soundin  \"../scores/samples/apoc.aiff\"\nain2     soundin  \"../scores/samples/apoc.aiff\"\n\nkin1     downsamp  ain1                ; Convert to kr\nkin2     downsamp  ain2                ; Convert to kr\nk1       = ( kin1 > 0 ? 1 : 0 )        ; See if above zero crossing line\nk2       = ( kin2 > 0 ? 1 : 0 )        ; See if above zero crossing line\nif       k1 + k2 == 0 goto xor1        ; If both below, goto xor1\nif       k1 + k2 == 1 goto xor2        ; If 1 below goto xor2\nxor1:                                  ; If neither below, also go to xor1\naexor    = 0                           ; Set Exclusive OR gate to 0...\ngoto     out                           ; ...then goto out\nxor2:\naexor    = 1                           ; Set Exclusive OR gate to 1\nout:\nouts1    aexor*ain1 + (1 - aexor)*ain2 ; Gate signals and output L\nouts2    (1 - aexor)*ain1 + aexor*ain2 ; Gate signals and output R\n\nendin\n\n</CsInstruments>\n<CsScore>\n;AND/NAND\n;     Strt  Leng  Levl\ni01   0.00  1.50  1.00\n\n;Exclusive OR\n;     Strt  Leng  Levl\ni02   2.00  1.50  1.00\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from 60_22_1c.orc and 60_22_1c.sco\n; Original files preserved in same directory\n\nsr = 44100\nkr  =  441\nksmps= 100\nnchnls = 1\n\n; ************************************************************************\n; ACCCI:      60_22_1C.ORC\n; synthesis:  phase vocoder(60)\n;             ktimpnt variable(22)\n;             pointer control by LINE, snap1.pvc(1C)\n; coded:      jpg 12/93\n\n\n\n\ninstr 1; *****************************************************************\nidur = p3\n\n   ktimpnt   line   .71, idur, .75\n   aout      pvoc   ktimpnt, 1.0, \"snap1.pvc\"\n             out    aout\nendin\n\n\n</CsInstruments>\n<CsScore>\n; ************************************************************************\n; ACCCI:   60_22_1C.SCO\n; coded:   jpg 12/93\n\n\n; score ******************************************************************\n;         idur\n\ni1   0    10      ; 10 s/.04 s   250 times larger\n\ne\n\n\n\n\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a envelopecopy sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from EnvelopeCopy.orc and EnvelopeCopy.sco\n; Original files preserved in same directory\n\nsr     = 44100\nkr     = 44100\nksmps  = 1\nnchnls = 1\n\n\ninstr    1 ; Replaces envelope of one sound with that of another\n\nilevl    = p4                            ; Output level\nkenv1    init 1                          ; Initialize output 1\nkenv2    init 1                          ; Initialize output 2\n\nain1     soundin  \"Sample1\"              ; Carrier\nain2     soundin  \"Sample2\"              ; Modulator\n\nkin1     downsamp  ain1                  ; Convert to kr\nkin1     mirror  kin1, 0, 32767          ; Full wave rectify\nif       kin1 > kenv1 goto up1           ; See if input larger than output\nkenv1    = kenv1 - ((32767 - kin1)/1000) ; Release\ngoto     out1\nup1:\nkenv1    = kin1                          ; Attack\nout1:\naout1    = ain1*(32767/(kenv1 + 1))      ; De-envelope\nkin2     downsamp  ain2                  ; Convert to kr\nkin2     mirror  kin2, 0, 32767          ; Full wave rectify\nif       kin2 > kenv2 goto up2           ; See if input larger than output\nkenv2    = kenv2 - ((32767 - kin2)/1000) ; Release\ngoto     out2\nup2:\nkenv2    = kin2                          ; Attack\nout2:\naout2    = aout1*(kenv2/32767)           ; Apply new envelope\nout      aout2*ilevl                     ; Level and output\n\nendin\n</CsInstruments>\n<CsScore>\n;     Strt  Leng  Levl\ni01   0.00  1.50  1.00\ne\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a lorenz sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from lorenz2.orc and lorenz2.sco\n; Original files preserved in same directory\n\nsr        =         44100\nkr        =         4410\nksmps     =         10\nnchnls    =         1    \n\n\n          instr 1\n\n; LORENZ EQUATIONS SYSTEM AT A-RATE WITH ALL PARAMETERS TIME-VARIABLE \n\n\nipi       init      6.283184\namix      init      0\n\n; p4 p5 i p6 = initial values for control parameters \n; p7 = time differential (not less than 0.02 - may be improved using Runge-Kutta\n;    integration methode but it is very time consuming )\n; p8 amplitude\n; p9 zoom factor (a kind of temporal window applied to trajectories, values of \n;    aprox. 5 are equivalent-almost- to downing p7 at the price of\n;    a bit slowing down computing time...)\n; p10 p11 p12 = deviation value for p6 p7 p8 \n;    (It is implemented with a simple line statement, but\n;    improving it is straightforward)\n\n\nkcontzoom init      0\nkzoom     init      p9\n\niprof     init      p8\nidt       init      p7\n\n; NEWTON INTEGRATION METHODE\n\nadx       init      0                        ; DIFERENTIALS\nady       init      0\nadz       init      0\nax        init      .6                       ; VALUES\nay        init      .6\naz        init      .6\n\n; aa, ab AND ac HOLDS FOR THE VALUES OF CONTROL PARAMETERS \n\naa        line      p4,p3,p4+p10\nab        line      p5,p3,p5+p11\nac        line      p6,p3,p6+p12\n\naa        init      p4\nab        init      p5\nac        init      p6\n\nloop1: \nadx       =         aa*(ay-ax)\nady       =         ax*(ab-az)-ay\nadz       =         ax*ay-ac*az\nax        =         ax+(idt*adx)\nay        =         ay+(idt*ady)\naz        =         az+(idt*adz)\n\nkcontzoom =         kcontzoom+1\n\n          if        kcontzoom>=kzoom kgoto sortida\n          if        kcontzoom!=kzoom kgoto loop1\n\nsortida:\namix      =         ax*iprof\n\n          out       amix\n\nkcontzoom =         0\n\n          endin\n\n</CsInstruments>\n<CsScore>\n; istart idur A1 B1 C1   Time (dT) Amplitude KZoom A2 B2 C2\ni1 0 .5 22 28 2.667 .01  600  3    5 0 0\ns\ni1 0 3 26 28 2.667  .01  600  4    0 10 0\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a mixer sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from MIXER1.ORC and MIXER1.SCO\n; Original files preserved in same directory\n\n     sr             =         44100\n     kr             =         4410\n     ksmps          =         10\n     nchnls         =         2\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;         MASTER MIXER AND PANNER                       ;\n;                                                       ;\n;         P3 = DURATION                                 ;\n;         P4 = AMPLITUDE FACTOR FOR SIGNAL              ;\n;      P5 = PANNING FUNCTION FOR SIGNAL                 ;\n;      P6 = ENVLPX ATTACK FOR SIGNAL                    ;\n;      P7 = ENVLPX DECAY FOR SIGNAL                     ;\n;      P8 = SOUNDIN FILE NUMBER                         ;\n;      P9 = SKIPTIME                                    ;\n;                                                       ;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n                    instr     1\n     a1             soundin   p8,p9\n     kenv           envlpx    p4,p6,p3,p7,5,1,.01\n     asig           =         a1*kenv\n     kramp          oscil1i   0.0,1,p3,p5\n     kfacl          =         sqrt (kramp)\n     kfacr          =         sqrt (1-kramp)\n     alft           =         asig * kfacl  \n     arght          =         asig * kfacr  \n                    outs      alft,arght\n                    endin\n\n</CsInstruments>\n<CsScore>\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;         MASTER MIXER AND PANNER SCORE                 ;\n;                                                       ;\n;         P3 = DURATION                                 ;\n;         P4 = AMPLITUDE FACTOR FOR SIGNAL              ;\n;      P5 = PANNING FUNCTION FOR SIGNAL      ;\n;      P6 = ENVLPX ATTACK FOR SIGNAL         ;\n;      P7 = ENVLPX DECAY FOR SIGNAL               ;\n;      P8 = SOUNDIN FILE NUMBER              ;\n;      P9 = SKIPTIME                    ;\n;                                                       ;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;         FUNCTIONS\n;\n;    ALL LEFT\nf1 0.0 512 7 1 512 1\n;    ALL RIGHT\nf2 0.0 512 7 0 512 0\n;    MIDDLE\nf3 0.0 512 7 .5 512 .5\n;    LEFT TO RIGHT\nf4 0.0 513 7 1 512 0 1 0\n;    RIGHT TO LEFT\nf5 0.0 513 7 0 512 1 1 1\n;    LEFT TO RIGHT TO LEFT\nf6 0.0 513 7 1 256 0 256 1 1 1\n;    RIGHT TO LEFT TO RIGHT\nf7 0.0 513 7 0 256 1 256 0 1 0\n;    ALL OVER THE PLACE\nf8 0.0 513 7 .5 63 .95 50 0 50 .3 50 .85 50 .80 50 .03 50 1 50 .12 50 .10 50 .5\n;    ALSO ALL OVER THE PLACE\nf9 0.0 513 7 .5 63 .95 50 .02 50 .3 50 .85 50 .80 50 .06 50 .98 50 .03 50 .10 50 .5\n;    ALL LEFT THEN ALL RIGHT\nf10 0.0 513 7 1 256 1 1 0 256 0\n;\n;    INSTRUMENT CARDS\n;\ni1    0.00   3.00  0.50  4  0.010   0.010  5  0.0000\ni1    2.00   3.00  0.70  5  0.010   0.010  5  0.1000\ni1    5.00   3.00  0.30  8  0.010   0.010  5  0.3000\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a testone sound using test/demonstration", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from testone2.orc and testone2.sco\n; Original files preserved in same directory\n\nsr        =         44100\nkr        =         4410\nksmps     =         10\nnchnls    =         1\n\n                                             \n          instr 12       \naph       phasor    100                      ; PHASES 0-1 100 TIMES/SECOND\nilength   =         ftlen(p4)\naph       =         aph*ilength\na1        table     aph, p4\nkph       downsamp  aph\nk1        downsamp  a1\n          out       a1*20000\n          printks   \"address=%6.4f\\t value=%6.4f\\n\", .01, kph, k1, 0, 0\n          display   a1, .01\n          endin\n\n          instr 13       \naph       phasor    100                      ; PHASES 0-1 100 TIMES/SECOND\nilength   =         ftlen(p4)\naph       =         aph*ilength\na1        tablei    aph, p4\nkph       downsamp  aph\nk1        downsamp  a1\n          out       a1*20000\n          printks   \"address=%6.4f\\t value=%6.4f\\n\", .01, kph, k1, 0, 0\n          display   a1, .01\n          endin\n\n</CsInstruments>\n<CsScore>\nf1\t0\t4096\t10\t1 ;sine\nf2\t0\t1024\t10\t1 ;sine\nf3\t0\t128\t\t10\t1 ;sine\nf4\t0\t16\t\t10\t1 ;sine\nf5\t0\t8\t\t10\t1 ;sine\n\ni12\t  0\t\t1\t1\ni12\t  2\t\t1\t2\t\t\t\t\t\t\t\t \ni12\t  4\t\t1\t3\t\t\t\t\t\t\t\t \ni12\t  6\t\t1\t4\ni12\t  8\t\t1\t5\ns\ni13\t  0\t\t1\t1\ni13\t  2\t\t1\t2\t\t\t\t\t\t\t\t \ni13\t  4\t\t1\t3\t\t\t\t\t\t\t\t \ni13\t  6\t\t1\t4\ni13\t  8\t\t1\t5\n\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a cannon sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from cannon.orc and cannon.sco\n; Original files preserved in same directory\n\nsr        =         44100\nkr        =         4410\nksmps     =         10\nnchnls    =         1\n\n\ninstr 5\n     a1   linrand   20000\n     out  a1\nendin\n\ninstr 4\n     a1   trirand   20000\n     out  a1\nendin\n\ninstr 3\n     a1   gauss     20000\n     out  a1\nendin\n\ninstr 2\n     a1   weibull   250, .5\n     out  a1\nendin\n\ninstr 1\n     a1   betarand 20000, .5, .5\n     out  a1\nendin\n\n</CsInstruments>\n<CsScore>\nf1 0 1024 21 1\nf2 0 1024 21 2 1\nf3 0 1024 21 3 1\nf4 0 1024 21 4 1\nf5 0 1024 21 5 1\nf6 0 1024 21 6 1\nf7 0 1024 21 7 1\nf8 0 1024 21 8 1\nf9 0 1024 21 9 1 1 2\nf10 0 1024 21 10 1 2\nf11 0 1024 21 11 1\n\ni1 0 2\ns\ni2 1 2\ns\ni3 1 2\ns\ni4 1 2\ns\ni5 1 2\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from pm6.orc and pm6.sco\n; Original files preserved in same directory\n\nsr        =         44100\nkr        =         4410\nksmps     =         10\nnchnls    =         1\n\n\n;\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n          instr 1             ; square (4 masses) plate, all masses grounded\n; coded by Josep M Comajuncosas / gelida@intercom.es\n;\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\n; SET INITIAL POSITION AND VELOCITY OF THE MASS\niv0       =         0\nix0       =         10000\n\n; SET K, Z AND M\nik        =         p4\niz        =         p5\nim2       =         25\nim3       =         31\nim4       =         27\nim5       =         29\n\n; NORMALIZE (DON'T TOUCH THIS!)\nik        =         ik/(sr*sr)\niz        =         iz/(1000000000*sr)       ; Z GIVEN IN N*s/(kg*10e-9)\nim2       =         im2/1000000000           ; MASS GIVEN IN kg*10e-9\nim3       =         im3/1000000000\nim4       =         im4/1000000000\nim5       =         im5/1000000000\n\nax2       init      ix0\naxprev2   init      ix0-1000*iv0/sr\n\n\nax3       init      0\nax4       init      0\nax5       init      0\naxprev3   init      0\naxprev4   init      0\naxprev5   init      0\n\naf1       =         ik*(ax2) + iz*((ax2-axprev2))+ ik*(ax3) + iz*((ax3-axprev3)) + ik*(ax4) + iz*((ax4-axprev4)) + ik*(ax5) + iz*((ax5-axprev5))\naf2       =         -af1 + ik*(ax3-ax2) + iz*((ax3-axprev3)-(ax2-axprev2)) + ik*(ax5-ax2) + iz*((ax5-axprev5)-(ax2-axprev2))\naf3       =         -af1 - af2 + ik*(ax4-ax3) + iz*((ax4-axprev4)-(ax3-axprev3))\naf4       =         -af1 - af3 + ik*(ax5-ax4) + iz*((ax5-axprev5)-(ax4-axprev4))\naf5       =         -af1 - af4 - af2\n\n\nanext2    =         af2/im2 + 2*ax2-axprev2\nanext3    =         af3/im3 + 2*ax3-axprev3\nanext4    =         af4/im4 + 2*ax4-axprev4\nanext5    =         af5/im5 + 2*ax5-axprev5\n\n          out       ax3\n\naxprev2   =         ax2\naxprev3   =         ax3\naxprev4   =         ax4\naxprev5   =         ax5\n\nax2       =         anext2\nax3       =         anext3\nax4       =         anext4\nax5       =         anext5\n\n          endin\n\n</CsInstruments>\n<CsScore>\n;      k  damping\ni1 0 2 .01  100\ni1 2 2 .3  100\ni1 4 2 .8  200\ni1 6 2 .5  50\ni1 8 4 .05  10\n\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a function sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from Function.orc and Function.sco\n; Original files preserved in same directory\n\nsr       = 44100\nkr       = 4410\nksmps    = 10\nnchnls   = 1\n\n\ninstr    1 ; Log function distortion\n\nain      soundin  \"Sample2\"\n\na2       = (ain + 32767)/16384 ; Scale and DC shift\nalog     = log(a2)             ; Log function\nout      alog*16384            ; Scale output\n\nendin\n\ninstr    2 ; Polynominal function distortion\n\nain      soundin  \"Sample1\"\n\nain      = ain/32767           ; Scale input to +/-1\napoly    = ain - (ain*ain*ain) ; Polynominal function\nout      apoly*85196           ; Scale output\n\nendin\n\ninstr    3 ; x*2 - x^2 function (Even harmonic distortion)\n\nain      soundin  \"Sample2\"\n\nain      = ain/32767           ; Scale input to +/-1\napoly    = ain*2 - ain*ain     ; x*2 - x^2 function\nout      apoly*32767/3         ; Scale output\n\nendin\n\ninstr    4 ; x*3 - x^3 distortion (Compresses Signal)\n\nain      soundin  \"Sample1\"\n\nain      = ain/32767           ; Scale input to +/-1\napoly    = ain*3 - ain*ain*ain ; x*3 - x^3 function\nout      apoly*16384           ; Scale output\n\nendin\n\n</CsInstruments>\n<CsScore>\n;     Strt  Leng\ni01   0.00  1.50\n\n;     Strt  Leng\ni02   2.00  1.50\n\n;     Strt  Leng\ni03   4.00  1.50\n\n;     Strt  Leng\ni04   6.00  1.50\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a gates sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from Gates.orc and Gates.sco\n; Original files preserved in same directory\n\nsr       = 44100\nkr       = 44100\nksmps    = 1\nnchnls   = 1\n\n\ninstr    1 ; Gate - passes signal over threshold\n\nilevl    = p4       ; Level\nithresh  = p5*32768 ; Threshold\n\nain      soundin  \"Sample1\"\n\nkin      downsamp  ain\nkpos     limit  kin, 0, 32768\nkneg     limit  kin,-32768, 0\nkgate1   = (kpos > ithresh ? kpos : 0)\nkgate2   = (kneg <-ithresh ? kneg : 0)\nkgate    = kgate1 + kgate2\nagate    upsamp  kgate\nout      agate*ilevl\n\nendin\n\ninstr    2 ; Gate - passes signal under threshold\n\nilevl    = p4/p5    ; Level scaled to compensate for clipping\nithresh  = p5*32768 ; Threshold\n\nain      soundin  \"Sample2\"\n\nkin      downsamp  ain\nkpos     limit  kin, 0, 32768\nkneg     limit  kin,-32768, 0\nkgate1   = (kpos < ithresh ? kpos : 0)\nkgate2   = (kneg >-ithresh ? kneg : 0)\nkgate    = kgate1 + kgate2\nagate    upsamp  kgate\nout      agate*ilevl\n\nendin\n\ninstr    3 ; Gate - passes loudest input\n\nilevl    = p4 ; Output level\n\nain1     soundin  \"Sample1\"\nain2     soundin  \"Sample2\"\n\nkin1     downsamp  ain1\nkin2     downsamp  ain2\nkpos1    limit  kin1, 0, 32768\nkneg1    limit  kin1,-32768, 0\nkpos2    limit  kin2, 0, 32768\nkneg2    limit  kin2,-32768, 0\nkgate1   = (kpos1 > kpos2 ? kpos1 : kpos2)\nkgate2   = (kneg1 < kneg2 ? kneg1 : kneg2)\nkgate    = kgate1 + kgate2\nagate    upsamp  kgate\nout      agate*ilevl\n\nendin\n\ninstr    4 ; Gate - passes quietest input\n\nilevl    = p4 ; Output level\n\nain1     soundin  \"Sample1\"\nain2     soundin  \"Sample2\"\n\nkin1     downsamp  ain1\nkin2     downsamp  ain2\nkpos1    limit  kin1, 0, 32768\nkneg1    limit  kin1,-32768, 0\nkpos2    limit  kin2, 0, 32768\nkneg2    limit  kin2,-32768, 0\nkgate1   = (kpos1 < kpos2 ? kpos1 : kpos2)\nkgate2   = (kneg1 > kneg2 ? kneg1 : kneg2)\nkgate    = kgate1 + kgate2\nagate    upsamp  kgate\nout      agate*ilevl\n\nendin\n\n</CsInstruments>\n<CsScore>\n;Passes signal over threshold\n;     Strt  Leng  Levl  Thresh\ni01   0.00  1.50  1.00  0.50\n\n;Passes signal under threshold\n;     Strt  Leng  Levl  Thresh\ni02   2.00  1.50  1.00  0.25\n\n;Passes loudest input\n;     Strt  Leng  Levl\ni03   4.00  1.50  1.00\n\n;Passes quietest input\n;     Strt  Leng  Levl\ni04   6.00  1.50  1.00\ne\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from pm7.orc and pm7.sco\n; Original files preserved in same directory\n\nsr        =         44100\nkr        =         4410\nksmps     =         10                       ; DON´T CHANGE IT!\nnchnls    =         1\n\n\n;\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n          instr 1             ; HAMMER ACTION SIMULATOR\n;\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\n; SET INITIAL POSITION AND VELOCITY OF THE MASS\niv0       =         0\nix0       =         25000\n\n; SET K, Z AND M\nik        =         p4\niz        =         p5\nim2       =         30\nim3       =         22\n\n; NORMALIZE (DON'T TOUCH THIS!)\nik        =         ik/(sr*sr)\niz        =         iz/(1000000000*sr)       ; Z GIVEN IN N*s/(kg*10e-9)\nim2       =         im2/1000000000           ; MASS GIVEN IN kg*10e-9\nim3       =         im3/1000000000           ; MASS GIVEN IN kg*10e-9\n\nkx3       init      ix0\nkxprev3   init      ix0-1000*iv0/sr\n\nkx2       init      0\nkxprev2   init      0\n\nkf1       =         ik*(kx2) + iz*((kx2-kxprev2))\n          if        kx3 > kx2 goto nolink\nkf2       =         -kf1 + ik*(kx3-kx2) + iz*((kx3-kxprev3)-(kx2-kxprev2))\nkf3       =         -kf2 + ik*(-kx3) + iz*(-(kx3-kxprev3))\n          goto      next\n\nnolink:\nkf2       =         -kf1\nkf3       =         ik*(-kx3) + iz*(-(kx3-kxprev3))\n\nnext:\nknext2    =         kf2/im2 + 2*kx2-kxprev2\nknext3    =         kf3/im3 + 2*kx3-kxprev3\n\n          aout      upsamp knext2  \n          out       aout\n\nkxprev2   =         kx2\nkxprev3   =         kx3\nkx2       =         knext2\nkx3       =         knext3\n          endin\n\n</CsInstruments>\n<CsScore>\n;      k  damping\ni1 0 2 .1  300\ni1 2 2 .05 500\ni1 4 2 .2  200\ni1 6 6 .01  50\ni1 12 25 .03  5\n\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from pm5.orc and pm5.sco\n; Original files preserved in same directory\n\nsr        =         44100\nkr        =         4410\nksmps     =         10                       ; ESSENTIAL FOR THIS INSTRUMENT. DON´T CHANGE IT!\nnchnls    =         1\n\n;pm5.orc\n\ngimaxn    =         20                       ;THE MAXIMUM NUMBER OF DISCRETE MASSES YOU´LL USE\n; ALLOCATE SOME zak SPACE\n          zakinit   1,4*gimaxn               ; WE SHOULD NEED A 4-DIMENSIONAL ARRAY HERE \n; (ACTUAL, PREVIOUS AND NEXT POSITIONS, AND ACTUAL FORCES)\n\n\n;\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n; strange plucked string. 20 masses! (be patient)\n          instr 1             ; AS pm4 WITH ARBITRARY MASSES AND POSITIONS\n; coded by Josep M Comajuncosas / Barcelona - jan.´98\n; gelida@intercom.es\n; variables to play with : inm (<=gimaxn), k (0 to 1), z\n;\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\ninm       =         20                       ; 98 EFFECTIVE MASSES (BOTH GROUNDS ACT LIKE INFINITE MASSES)\nkndx      init      1\n\n; SET K AND Z\nik        =         p4\niz        =         p5\n\n; NORMALIZE (DON'T TOUCH THIS!)\nik        =         ik/(sr*sr)\niz        =         iz/(1000000000*sr)\n\nimaxx     =         2000\nimaxm     =         40\nkskip     init      0\n          if        kskip == 1 kgoto noinitveloc\n\n; INITIALIZE POSITIONS WITH A WAVEFORM (f2)\n; INITIAL VELOCITIES ARE SET TO 0\nloop0:\nkiprevx   table     kndx/inm, 2, 1\n          zkw       imaxx*(kiprevx), kndx\n          zkw       imaxx*(kiprevx), inm + kndx\n\nkndx      =         kndx +1\n          if        kndx < inm -1 goto loop0\nkndx      =         0\nkskip     =         1\n\nnoinitveloc:\n\n; CALCULATE ACTUAL FORCES AND POSITIONS OF MASSES\n\n; \"MASS\" ON THE LEFT - GROUND\nkrightx   zkr       kndx +1\nkprevrightx zkr     kndx + inm +1\nkf        =         ik*(krightx) + iz*((krightx-kprevrightx))\n          zkw       kf, kndx + 3*inm\nkndx      =         kndx + 1\n\n; CENTRAL MASSES\nloop1:\n\n; INITIALIZE MASSES (f1)\nkm        tablei    kndx/inm, 1, 1\nkm        =         imaxm*(km+1)/2           ; FOR A TABLE IN (-1,1) - MASSES MUST BE > 0!\n;km       =         imaxm*km; for a table in (0,1)\nkm        =         km/1000000000; don´t touch!\n\nkx        zkr       kndx\nkprevx    zkr       kndx + inm\nkrightx   zkr       kndx +1\nkprevrightx zkr     kndx + inm +1\nkleftf    zkr       kndx + 3*inm -1\n\nkf        =         -kleftf + ik*(krightx-kx) + iz*((krightx-kprevrightx)-(kx-kprevx))\nknextx    =         kf/km + 2*kx-kprevx\n          zkw       kf, kndx + 3*inm\n          zkw       knextx, kndx + 2*inm\n\nkndx      =         kndx + 1\n          if        kndx < inm-1 goto loop1\n\n; \"MASS\" ON THE RIGHT - GROUND\nkx        zkr       kndx \nkprevx    zkr       kndx + inm\nkleftf    zkr       kndx + 3*inm -1\nkf        =         -kleftf + ik*(-kx) + iz*(-(kx-kprevx))\n          zkw       kf, kndx + 3*inm\n\n; UPDATE VARIABLES FOR NEXT PASS\nkndx      =         1\nloop2:\nkx        zkr       kndx\nknextx    zkr       kndx + 2*inm\n\n          zkw       kx, kndx + inm\n          zkw       knextx, kndx\n          zkw       0, kndx + 2*inm          ; THIS SHOULD´T BE NECESSARY (?)\n          zkw       0, kndx + 3*inm          ; ID. (?)\n\nkndx      =         kndx + 1\n          if        kndx < inm -1 goto loop2\n\n          kout      zkr int(inm/2)\n          aout      upsamp kout\n          out       aout\n\nkndx      =         0\n          endin\n\n          instr 2\n          zkcl      0, 4*gimaxn              ; SORRY FOR THE TRICK !\n          endin\n\n; i fer turnon 2,0 i a 2 zkcl -> turnoff?\n; o bé zkcl turnon 2,p3 turnoff tot a instr 1, amb gip4 gip5\n\n</CsInstruments>\n<CsScore>\nf1 0 1025 7 -1 1024 1; for a linear mass distribution\n;f1 0 256 7 -1 1024 21 1; random values...\n\nf2 0 256 11 50; initial pulse to excite the string\n\n;         k  damping\n; for lower damping values the instruments gets crazy (?) \ni2 0 .01\ni1 .02 2 .4  1000\ns\ni2 0 .01\ni1 .02 2 .3  300\ns\ni2 0 .01\ni1 .02 15 .5  100\ns\ni2 0 .01\ni1 .02 10 .6  200\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from pm4.orc and pm4.sco\n; Original files preserved in same directory\n\nsr        =         44100\nkr        =         4410\nksmps     =         10                       ; DON´T CHANGE IT!\nnchnls    =         1\n\n\ngimaxn    =         20\n; ALLOCATE SOME zak SPACE\n          zakinit   1,4*gimaxn               ; WE SHOULD NEED A 4-DIMENSIONAL ARRAY HERE \n; (ACTUAL, PREVIOUS AND NEXT POSITIONS, AND ACTUAL FORCES)\n; imaxn IS THE MAXIMUM NUMBER OF DISCRETE MASSES YOU´LL USE\n\n\n;\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n          instr 1             ; STRING WITH ARBITRARY N MASSES. CONSTANT LINEAR DENSITY\n; coded by Josep M Comajuncosas / gelida@intercom.es\n;\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\ninm       =         20                       ; 18 EFFECTIVE MASSES (BOTH GROUNDS ACT LIKE INFINITE MASSES)\nkndx      init      0\n\n; SET INITIAL POSITION AND VELOCITY OF THE MASS\n          ziw       15, 3 + inm              ; INITIALIZE ONE POSITION - HERE, THE PREVIOUS POSITION OF THE 4th MASS\n          ziw       15, 3                    ; INITIALIZE ONE POSITION - HERE, THE ACTUAL POSITION OF THE 4th MASS\n\n; SET K, Z AND M\nik        =         p4\niz        =         p5\nim        =         30\n\n; NORMALIZE (DON'T TOUCH THIS!)\nik        =         ik/(sr*sr)\niz        =         iz/(1000000000*sr)       ; Z GIVEN IN N*s/(kg*10e-9)\nim        =         im/1000000000            ; MASS GIVEN IN kg*10e-9\n\n\n; CALCULATE ACTUAL FORCES AND POSITIONS OF MASSES\n\n; \"MASS\" ON THE LEFT - GROUND\nkrightx   zkr       kndx +1\nkprevrightx zkr     kndx + inm +1\nkf        =         ik*(krightx) + iz*((krightx-kprevrightx))\n          zkw       kf, kndx + 3*inm\nkndx      =         kndx + 1\n\n; CENTRAL MASSES\nloop1:\nkx        zkr       kndx\nkprevx    zkr       kndx + inm\nkrightx   zkr       kndx +1\nkprevrightx zkr     kndx + inm +1\nkleftf    zkr       kndx + 3*inm -1\n\nkf        =         -kleftf + ik*(krightx-kx) + iz*((krightx-kprevrightx)-(kx-kprevx))\nknextx    =         kf/im + 2*kx-kprevx\n          zkw       kf, kndx + 3*inm\n          zkw       knextx, kndx + 2*inm\n\nkndx      =         kndx + 1\n          if        kndx < inm-1 goto loop1\n\n; \"MASS\" ON THE RIGHT - GROUND\nkx        zkr       kndx \nkprevx    zkr       kndx + inm\nkleftf    zkr       kndx + 3*inm -1\nkf        =         -kleftf + ik*(-kx) + iz*(-(kx-kprevx))\n          zkw       kf, kndx + 3*inm\n\n; UPDATE VARIABLES FOR NEXT PASS\nkndx      =         1\nloop2:\nkx        zkr       kndx\nknextx    zkr       kndx + 2*inm\n\n          zkw       kx, kndx + inm\n          zkw       knextx, kndx\n          zkw       0, kndx + 2*inm          ; THIS SHOULD´T BE NECESSARY (?)\n          zkw       0, kndx + 3*inm          ; ID. (?)\n\nkndx      =         kndx + 1\n          if        kndx < inm -1 goto loop2\n\n          kout      zkr 3\n          aout      upsamp kout              ; I´M AFRAID THIS IS THE BEST WAY TO DO IT...\n          out       aout\n\nkndx      =         0\n          endin\n\n          instr 2\n          zkcl      0, 4*gimaxn              ; SORRY FOR THE TRICK !\n          endin\n\n</CsInstruments>\n<CsScore>\n;         k  damping\ni2 0 .01\ni1 .02 2 .4  1300\ns\ni2 0 .01\ni1 .02 2 .3  1100\ns\ni2 0 .01\ni1 .02 2 .5  1800\ns\ni2 0 .01\ni1 .02 2 .6  600\ns\ni2 0 .01\ni1 .02 5 .2  500\ns\ni2 0 .01\ni1 .02 10 .5  300\n\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from 88_01_2.orc and 88_01_2.sco\n; Original files preserved in same directory\n\nsr =    1\nkr  =   1\nksmps = 1\nnchnls= 1\n\n; ************************************************************************\n; ACCCI:     88_01_2.ORC\n; timbre:    none\n; synthesis: calculation of a function, writing as soundfile to disk\n; source:    endless.orc, M.I.T.(1993)\n; note:      F(kx) = exp(-4.8283*(1-cos(2*pi*(kx-255.5)/511)))\n; coded:     jpg 9/93\n\n\n\n\ninstr 1; *****************************************************************\nipi    =     3.14159\nisize  =     p3-1          ; since sr=1, p3 has number of locs to generate\nkx     init  0\n\n   aval  =        exp(-4.8283*(1-cos(2*ipi*(kx-(isize*.5))/isize)))\n   kx    =        kx+1\n         display  aval,p3*.5\n         display  aval,p3\n         out      aval * 32000   ; 1 < aval < -1  use whole range of amps\n\nendin\n\n\n</CsInstruments>\n<CsScore>\n; ************************************************************************\n; ACCCI:       88_01_2.SCO\n; coded:       jpg 9/93\n\n; score ******************************************************************\n;  start  table length\ni1 0      2049\n\ne\n\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from 60_22_2.orc and 60_22_2.sco\n; Original files preserved in same directory\n\nsr = 44100\nkr  =  441\nksmps= 100\nnchnls = 1\n\n; ************************************************************************\n; ACCCI:      60_22_2.ORC\n; synthesis:  phase vocoder(60)\n;             ktimpnt variable(22)\n;             pointer control by EXPON, santur1.pvc(2)\n; coded:      jpg 12/93\n\n\n\n\ninstr 1; *****************************************************************\nidur    = p3\nifildur = 5\n\n   ktimpnt   expon  .1, idur, ifildur\n   aout      pvoc   ktimpnt, 1.0, \"santur1.pvc\"\n             out    aout\nendin\n\n\ninstr 2; *****************************************************************\nidur    = p3\nifildur = 5\n\n   ktimpnt   expon  ifildur, idur, .1\n   aout      pvoc   ktimpnt, 1.0, \"santur1.pvc\"\n             out    aout\nendin\n\n</CsInstruments>\n<CsScore>\n; ************************************************************************\n; ACCCI:   60_22_2.SCO\n; coded:   jpg 12/93\n\n\n; score ******************************************************************\n;         idur\ni1    0     5  ; forward up\ni2    5    10  ; and backwards down\ne\n\n\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from pm3.orc and pm3.sco\n; Original files preserved in same directory\n\nsr        =         44100\nkr        =         4410\nksmps     =         10\nnchnls    =         1\n\n\n;\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n        instr 1         ; Two masses, both ends. Scheme : (grnd)<-->m2<-->m3<-->(grnd)\n;coded by Josep M Comajuncosas / gelida@intercom.es\n;\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\n; SET INITIAL POSITION AND VELOCITY OF THE MASS\niv0     =       0\nix0     =       10000\n\n; SET K, Z AND M\nik      =       p4\niz      =       p5\nim2     =       30\nim3     =       30\n\n; NORMALIZE (DON'T TOUCH THIS!)\nik      =       ik/(sr*sr)\niz      =       iz/(1000000000*sr)  ; Z GIVEN IN N*s/(kg*10e-9)\nim2     =       im2/1000000000; mass given in kg*10e-9\nim3     =       im3/1000000000; mass given in kg*10e-9\n\nax2     init    ix0\naxprev2 init    ix0-1000*iv0/sr\n\nax3     init    0\naxprev3 init    0\n\naf1     =       ik*(ax2) + iz*((ax2-axprev2))\naf2     =       -af1 + ik*(ax3-ax2) + iz*((ax3-axprev3)-(ax2-axprev2))\naf3     =       -af2 + ik*(-ax3) + iz*(-(ax3-axprev3))\n\nanext2  =       af2/im2 + 2*ax2-axprev2\nanext3  =       af3/im3 + 2*ax3-axprev3\n\n        out     ax3\n\naxprev2 =       ax2\naxprev3 =       ax3\nax2     =       anext2\nax3     =       anext3\n        endin\n\n\n</CsInstruments>\n<CsScore>\n;      k  damping\ni1 0 2 .1  5000\ni1 2 2 .3  1000\ni1 4 2 .8  200\ni1 6 2 .5  50\ni1 8 2 .9  10\n\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a threshold sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from Threshold.orc and Threshold.sco\n; Original files preserved in same directory\n\nsr     = 44100\nkr     = 44100\nksmps  = 1\nnchnls = 1\n\n\ninstr    1 ; Gate - passes signal over threshold\n\nilevl    = p4       ; Level\nithresh  = p5*32768 ; Threshold\n\nain      soundin  \"Sample1\"\nkin      downsamp  ain\n\nkpos     limit  kin, 0, 32768\nkneg     limit  kin,-32768, 0\n\nkgate1   = (kpos > ithresh ? kpos : 0)\nkgate2   = (kneg <-ithresh ? kneg : 0)\n\nkgate    = kgate1 + kgate2\nagate    upsamp  kgate\n\nout      agate*ilevl\n\nendin\n\ninstr    2 ; Gate - passes signal under threshold\n\nilevl    = p4/p5    ; Level scaled to compensate for clipping\nithresh  = p5*32768 ; Threshold\n\nain      soundin  \"Sample1\"\nkin      downsamp  ain\n\nkpos     limit  kin, 0, 32768\nkneg     limit  kin,-32768, 0\n\nkgate1   = (kpos < ithresh ? kpos : 0)\nkgate2   = (kneg >-ithresh ? kneg : 0)\n\nkgate    = kgate1 + kgate2\nagate    upsamp  kgate\n\nout      agate*ilevl\n\nendin\n\n</CsInstruments>\n<CsScore>\n;passes signal over threshold\n\n;   Strt  Leng  Levl  Thresh\ni1  0.00  1.47  1.00  0.25\n\n;passes signal under threshold\n\n;   Strt  Leng  Levl  Thresh\ni2  2.00  1.47  1.00  0.25\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from pm2.orc and pm2.sco\n; Original files preserved in same directory\n\nsr        =         44100\nkr        =         4410\nksmps     =         10\nnchnls    =         1\n\n\n;\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n        instr 1         ;   : m1<-->m2<-->(grnd)\n; coded by Josep M Comajuncosas / gelida@intercom.es\n;\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\ni2pi2   =       39.47841760436; (2pi)^2\n\n; SET INITIAL POSITION AND VELOCITY OF THE MASS\niv0     =       0\nix0     =       10000\n\n; SET FREQUENCY, Z AND M\n;ifreq  =       cpspch(p4)\nifreq   =       500\niz      =       p5\nim1     =       30\nim2     =       30\n                                    \n; NORMALIZE (DON'T TOUCH THIS!)\niz      =       iz/(1000000000*sr)  ; z given in N*s/(kg*10e-9)\nim1     =       im1/1000000000; mass given in kg*10e-9\nim2     =       im2/1000000000; mass given in kg*10e-9\n\n; CALCULATE K ACCORDING TO GIVEN FREQ\nik      =       i2pi2*ifreq*ifreq*im1\nik      =       ik/(sr*sr)\n\nax1     init    ix0\naxprev1 init    ix0-1000*iv0/sr\n\nax2     init    0\naxprev2 init    0\n\naf1     =       ik*(ax2-ax1) + iz*((ax2-axprev2)-(ax1-axprev1))\naf2     =       -af1 + ik*(-ax2) + iz*(-(ax2-axprev2))\n\nanext1  =       af1/im1 + 2*ax1-axprev1\nanext2  =       af2/im2 + 2*ax2-axprev2\n\n        out     anext2\n\naxprev1 =       ax1\naxprev2 =       ax2\nax1     =       anext1\nax2     =       anext2\n        endin\n\n\n</CsInstruments>\n<CsScore>\n;      freq  damping\ni1 0 2 8.00  5000\ni1 2 2 8.00  1000\ni1 4 2 8.00  200\ni1 6 2 8.00  50\ni1 8 2 8.00  10\ne\ns\ni1 0 2 6.00  100\ni1 2 2 7.00  100\ni1 4 2 8.00  100\ni1 6 2 9.00  100\ni1 8 2 10.00 100\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from 60_22_1.orc and 60_22_1.sco\n; Original files preserved in same directory\n\nsr = 44100\nkr  =  441\nksmps= 100\nnchnls = 1\n\n; ************************************************************************\n; ACCCI:      60_22_1.ORC\n; synthesis:  phase vocoder(60)\n;             ktimpnt variable(22)\n;             pointer control by LINE, santur1.pvc(1)\n; coded:      jpg 12/93\n\n\n\ninstr 1; *****************************************************************\nidur = p3\n\n   ktimpnt   line   0, idur, 5                ; original file is 5 seconds\n\n   aout      pvoc   ktimpnt, 1.0, \"santur1.pvc\"\n             out    aout\nendin\n\ninstr 2; *****************************************************************\nidur = p3\n\n   ktimpnt   line   5, idur, 0                        ; play it backwards\n\n   aout      pvoc   ktimpnt, 1.0, \"santur1.pvc\"\n             out    aout\nendin\n\n</CsInstruments>\n<CsScore>\n; ************************************************************************\n; ACCCI:   60_22_1.SCO\n; coded:   jpg 12/93\n\n; score ******************************************************************\n;         idur\ni1    0    5      ; original re-synthesized\ni2    7    5      ; backwards\ni1   15    15     ; blown up to 3 * original length\ni1   35     2.5   ; compressed to 1/2 of original length\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from 60_23_1.orc and 60_23_1.sco\n; Original files preserved in same directory\n\nsr = 44100\nkr  =  441\nksmps= 100\nnchnls = 1\n\n; ************************************************************************\n; ACCCI:      60_23_1.ORC\n; synthesis:  phase vocoder(60)\n;             kfmod variable(23)\n;             transposition control by EXPON, santur1.pvc(1)\n; coded:      jpg 12/93\n\n\n\n\ninstr 1; *****************************************************************\nidur    = p3\nitarget = p4\nioct    =  octpch(p5)\n\n   ktimpnt   line   0, idur, 5\n   kfmod     expon  .1, idur, .1+itarget\n   aout      pvoc   ktimpnt, cpsoct(ioct-.3*kfmod)/440, \"santur1.pvc\"\n             out    aout/3\nendin\n\n\n</CsInstruments>\n<CsScore>\n; ************************************************************************\n; ACCCI:   60_23_1.SCO\n; coded:   jpg 12/93\n\n\n; GEN functions **********************************************************\n; carrier\nf11   0 8193 10 1               ; sinus\n\n\n; score ******************************************************************\n;           idur  itarget     ipch\ni1    0.0     5      3        10.00\ni1    6.0     1      1         9.11\ni1     +      .      .        10.00\ni1     .      .      .        10.02\ne\n\n\n\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument that creates a lorenz sound", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from LORENZ.ORC and LORENZ.SCO\n; Original files preserved in same directory\n\nsr\t\t=\t\t44100\nkr\t\t=\t\t44100\nksmps\t=\t\t1\nnchnls\t=\t\t1\n\n\n\t\tinstr \t1\n\n; LORENZ EQUATIONS SYSTEM AT A-RATE WITH ALL PARAMETERS TIME-VARIABLE\n\n\nipi \t\tinit 6.283184\namix \tinit 0\n\n;p4 p5 i p6 = INITIAL VALUES FOR CONTROL PARAMETERS\n;p7 = TIME DIFFERENTIAL (NOT LESS THAN 0.02 - MAY BE IMPROVED USING RUNGE-KUTTA\n;\t   INTEGRATION METHODE BUT IT IS VERY TIME CONSUMING )\n;p8 AMPLITUDE\n;p9 ZOOM FACTOR (A KIND OF TEMPORAL WINDOW APPLIED TO TRAJECTORIES, VALUES OF\n;\t\t\t APROX. 5 ARE EQUIVALENT-ALMOST- TO DOWNING P7 AT THE PRICE OF\n;\t\t\t A BIT SLOWING DOWN COMPUTING TIME...)\n;p10 p11 p12 = DEVIATION VALUE FOR p6 p7 p8\n;\t\t\t (IT IS IMPLEMENTED WITH A SIMPLE LINE STATEMENT, BUT\n;\t\t\t  IMPROVING IT IS STRAIGHTFORWARD)\n\n\nkcontzoom init 0\nkzoom \tinit p9\niprof \tinit p8\nidt \t\tinit p7\n\n; NEWTON INTEGRATION METHODE\n\nadx \t\tinit 0\t\t;DIFERENTIALS\nady \t\tinit 0\nadz \t\tinit 0\nax \t\tinit .6\t  \t;VALUES\nay \t\tinit .6\naz \t\tinit .6\n\n;AA, AB AND AC HOLDS FOR THE VALUES OF CONTROL PARAMETERS\n\n\t  aa line p4,p3,p4+p10\n\t  ab line p5,p3,p5+p11\n\t  ac line p6,p3,p6+p12\n\naa init p4\nab init p5\nac init p6\n\nloop1: adx=aa*(ay-ax)\n\t  ady=ax*(ab-az)-ay\n\t  adz=ax*ay-ac*az\n\t  ax=ax+(idt*adx)\n\t  ay=ay+(idt*ady)\n\t  az=az+(idt*adz)\n\nkcontzoom=kcontzoom+1\n\nif kcontzoom>=kzoom kgoto sortida\nif kcontzoom!=kzoom kgoto loop1\n\nsortida:amix = ax*iprof\n\nout amix\n\nkcontzoom=0\n\nendin\n\n\n\n\n</CsInstruments>\n<CsScore>\n; SCORE******************************************************************\n;  P2     P3   P4   P5    P6     P7         P8         P9     P10 P11 P12\n;  istart idur A1   B1    C1     Time (dT)  Amplitude  KZoom  A2  B2  C2\ni1  0     .5    22   28   2.667      .01       600     3      5   0    0\n;i1  0     3    26   28   2.667      .01       600     4      0   10    0\n\n;e\n\n\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a Csound instrument", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac -d\n</CsOptions>\n<CsInstruments>\n; Converted from pm8.orc and pm8.sco\n; Original files preserved in same directory\n\nsr        =         44100\nkr        =         44100\nksmps     =         1                        ; ESSENTIAL FOR THIS INSTRUMENT. DON´T CHANGE IT!\nnchnls    =         1\n\n; pm5.orc\n\ngimaxn    =         20                       ;THE MAXIMUM NUMBER OF DISCRETE MASSES YOU´LL USE\n; ALLOCATE SOME zak SPACE\n          zakinit   1,4*gimaxn               ; WE SHOULD NEED A 4-DIMENSIONAL ARRAY HERE \n; (ACTUAL, PREVIOUS AND NEXT POSITIONS, AND ACTUAL FORCES)\n\n\n;\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n; strange strucked string. 20 masses! (be patient)\n          instr 1             ; AS pm5 WITH A HAMMER ACTION LINK (THE LAST ONE)\n; coded by Josep M Comajuncosas / Barcelona - jan.´98\n; gelida@intercom.es\n; variables to play with : inm (<=gimaxn), k (0 to 1), z\n;\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\ninm       =         20                       ; 98 EFFECTIVE MASSES (BOTH GROUNDS ACT LIKE INFINITE MASSES)\nkndx      init      1\n\n; SET K AND Z\nik        =         p4\niz        =         p5\n\n; NORMALIZE (DON'T TOUCH THIS!)\nik        =         ik/(sr*sr)\niz        =         iz/(1000000000*sr)\n\nimaxx     =         2000\nimaxm     =         40\nimhammer  =         20\n\nkskip     init      0\n          if        kskip == 1 kgoto noinitveloc\n\n; INITIALIZE POSITIONS WITH A WAVEFORM (f2)\n; INITIAL VELOCITIES ARE SET TO 0\nloop0:\nkiprevx   table     kndx/inm, 2, 1\n          zkw       imaxx*(kiprevx), kndx\n          zkw       imaxx*(kiprevx), inm + kndx\n\n\nkndx      =         kndx +1\n          if        kndx < inm -1 goto loop0\nkndx      =         0\nkskip     =         1\n\nnoinitveloc:\n\n; CALCULATE ACTUAL FORCES AND POSITIONS OF MASSES\n\n; \"MASS\" ON THE LEFT - GROUND\n\nkrightx   zkr       kndx +1\nkprevrightx zkr     kndx + inm +1\nkf        =         ik*(krightx) + iz*((krightx-kprevrightx))\n          zkw       kf, kndx + 3*inm\nkndx      =         kndx + 1\n\n; CENTRAL MASSES\nloop1:\n\n; INITIALIZE MASSES (f1)\nkm        tablei    kndx/inm, 1, 1\nkm        =         imaxm*(km+1)/2           ; FOR A TABLE IN (-1,1) - MASSES MUST BE > 0!\n;km       =         imaxm*km                 ; FOR A TABLE IN (0,1)\nkm        =         km/1000000000            ; DON´T TOUCH!\n\nkx        zkr       kndx\nkprevx    zkr       kndx + inm\nkrightx   zkr       kndx +1\nkprevrightx zkr     kndx + inm +1\nkleftf    zkr       kndx + 3*inm -1\n\nkf        =         -kleftf + ik*(krightx-kx) + iz*((krightx-kprevrightx)-(kx-kprevx))\nknextx    =         kf/km + 2*kx-kprevx\n          zkw       kf, kndx + 3*inm\n          zkw       knextx, kndx + 2*inm\n\nkndx      =         kndx + 1\n          if        kndx < inm-2 goto loop1\n\n; LAST MASS,HAMMER-TYPE LINK & GROUND \n\nkm        tablei    kndx/inm, 1, 1\nkm        =         imaxm*(km+1)/2           ; FOR A TABLE IN (-1,1) - MASSES MUST BE > 0!\n;km       =         imaxm*km                 ; FOR A TABLE IN (0,1)\nkm        =         km/1000000000            ; DON´T TOUCH!\n                                        \nkleftx    =         kx\nkx        =         krightx\nkprevx    zkr       kndx + inm\nkrightx   zkr       kndx +1\nkprevrightx zkr     kndx + inm +1\nkleftf    =         kf\n          if        kx > kleftx goto nolink\nkf        =         -kleftf + ik*(krightx-kx) + iz*((krightx-kprevrightx)-(kx-kprevx))\nkflast    =         -kf + ik*(-krightx) + iz*(-(krightx-kprevrightx))\n          goto      next\n\nnolink:\nkf        =         -kleftf\nkflast    =         ik*(-krightx) + iz*(-(krightx-kprevrightx))\n\nnext:\nknextx    =         kf/km + 2*kx-kprevx\nklastx    =         kflast/imhammer + 2*krightx-kprevrightx\n\n\n; UPDATE VARIABLES FOR NEXT PASS\nkndx      =         1\nloop2:\nkx        zkr       kndx\nknextx    zkr       kndx + 2*inm\n\n          zkw       kx, kndx + inm\n          zkw       knextx, kndx\n          zkw       0, kndx + 2*inm          ; THIS SHOULD´T BE NECESSARY (?)\n          zkw       0, kndx + 3*inm          ; ID. (?)\n\nkndx      =         kndx + 1\n          if        kndx < inm -1 goto loop2\n\n          kout      zkr int(inm/2)\n          aout      upsamp kout\n          out       aout\n\nkndx      =         0\n          endin\n\n          instr 2\n          zkcl      0, 4*gimaxn              ; SORRY FOR THE TRICK !\n          endin\n\n;i fer turnon 2,0 i a 2 zkcl -> turnoff?\n; o bé zkcl turnon 2,p3 turnoff tot a instr 1, amb gip4 gip5\n\n</CsInstruments>\n<CsScore>\nf1 0 1025 7 -1 1024 1; for a linear mass distribution\n;f1 0 256 7 -1 1024 21 1; random values...\n\nf2 0 256 11 50; initial pulse to excite the string\n\n;         k  damping\n; for lower damping values the instruments gets crazy (?) \ni2 0 .01\ni1 .02 2 .4  1000\ns\ni2 0 .01\ni1 .02 2 .3  300\ns\ni2 0 .01\ni1 .02 15 .5  100\ns\ni2 0 .01\ni1 .02 10 .6  200\ne\n\n</CsScore>\n</CsoundSynthesizer>"}
