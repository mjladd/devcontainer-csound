{"instruction": "Write a CSound instrument that demonstrates the phasor opcode by generating a sawtooth wave through table lookup", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac\n</CsOptions>\n<CsInstruments>\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n0dbfs = 1\n\n; Function table 1: sine wave for table lookup\ngiSine ftgen 1, 0, 8192, 10, 1\n; Function table 2: triangle wave\ngiTri ftgen 2, 0, 8192, 7, 0, 2048, 1, 4096, -1, 2048, 0\n\ninstr 1\n    ; phasor opcode: ares phasor xcps [, iphs]\n    ; phasor produces a normalized moving phase value (0-1)\n    ; xcps - frequency in Hz\n    ; iphs - initial phase (0-1, optional)\n    \n    ; Amplitude envelope\n    kAmp linseg 0, 0.05, 0.4, p3-0.1, 0.4, 0.05, 0\n    \n    ; Generate a phasor at 440 Hz\n    aPhs phasor 440\n    \n    ; Use phasor to read through the sine wave table\n    aSig tablei aPhs, giSine, 1\n    \n    out aSig * kAmp\nendin\n\ninstr 2\n    ; Demonstrate phasor for direct audio output (sawtooth)\n    kAmp linseg 0, 0.05, 0.3, p3-0.1, 0.3, 0.05, 0\n    \n    ; Phasor output (0-1) can be converted to audio (-1 to 1)\n    aPhs phasor 220\n    aSaw = (aPhs * 2) - 1\n    \n    out aSaw * kAmp\nendin\n\n</CsInstruments>\n<CsScore>\n\n; Play instrument 1 for 2 seconds\ni1 0 2\n; Play instrument 2 for 2 seconds starting at t=2.5\ni2 2.5 2\n\ne\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a CSound instrument that demonstrates the phasor opcode for phase modulation synthesis", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac\n</CsOptions>\n<CsInstruments>\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n0dbfs = 1\n\n; Function table: sine wave\ngiSine ftgen 1, 0, 8192, 10, 1\n\ninstr 1\n    ; phasor opcode: ares phasor xcps [, iphs]\n    ; Demonstrate phase modulation using phasor\n    ; xcps - frequency in Hz (can be k-rate or a-rate)\n    ; iphs - initial phase (0-1, optional)\n    \n    ; Amplitude envelope\n    kAmp linseg 0, 0.1, 0.4, p3-0.2, 0.4, 0.1, 0\n    \n    ; Modulator frequency\n    kModFreq = 5\n    \n    ; Create modulator phasor\n    aModPhs phasor kModFreq\n    aModSig = (aModPhs - 0.5) * 0.3\n    \n    ; Create carrier phasor with phase modulation\n    aCarPhs phasor 440\n    aModPhs = aCarPhs + aModSig\n    \n    ; Wrap phase to 0-1 range\n    aModPhs = aModPhs - int(aModPhs)\n    \n    ; Table lookup\n    aSig tablei aModPhs, giSine, 1\n    \n    out aSig * kAmp\nendin\n\n</CsInstruments>\n<CsScore>\n\n; Play instrument 1 for 3 seconds\ni1 0 3\n\ne\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a CSound instrument that demonstrates the phasor opcode for creating multiple detuned oscillators", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac\n</CsOptions>\n<CsInstruments>\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n0dbfs = 1\n\n; Function table: sine wave\ngiSine ftgen 1, 0, 16384, 10, 1\n\ninstr 1\n    ; phasor opcode: ares phasor xcps [, iphs]\n    ; Create a rich sound using multiple detuned phasors\n    ; xcps - frequency in Hz\n    ; iphs - initial phase (optional, use different values for spread)\n    \n    ; Base frequency\n    kFreq = 220\n    \n    ; Amplitude envelope\n    kAmp linseg 0, 0.1, 0.15, p3-0.2, 0.15, 0.1, 0\n    \n    ; Create multiple detuned phasors with different starting phases\n    aPhs1 phasor kFreq, 0\n    aPhs2 phasor kFreq * 1.005, 0.25\n    aPhs3 phasor kFreq * 0.995, 0.5\n    aPhs4 phasor kFreq * 1.01, 0.75\n    \n    ; Convert to audio signals\n    aSig1 tablei aPhs1, giSine, 1\n    aSig2 tablei aPhs2, giSine, 1\n    aSig3 tablei aPhs3, giSine, 1\n    aSig4 tablei aPhs4, giSine, 1\n    \n    ; Mix for stereo output\n    aLeft = (aSig1 + aSig3) * kAmp\n    aRight = (aSig2 + aSig4) * kAmp\n    \n    outs aLeft, aRight\nendin\n\n</CsInstruments>\n<CsScore>\n\n; Play instrument 1 for 4 seconds\ni1 0 4\n\ne\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a CSound instrument that demonstrates the phasorbnk opcode for generating multiple phase signals simultaneously", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac\n</CsOptions>\n<CsInstruments>\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n0dbfs = 1\n\n; Function table: sine wave\ngiSine ftgen 1, 0, 8192, 10, 1\n\ninstr 1\n    ; phasorbnk opcode: ares1 [, ares2] [, ...] phasorbnk xcps, kfn [, imax] [, ioffset] [, iphase]\n    ; phasorbnk produces multiple normalized moving phase values\n    ; xcps - base frequency in Hz\n    ; kfn - function table containing frequency ratios\n    ; imax - maximum number of oscillators (optional)\n    ; ioffset - frequency table offset (optional)\n    ; iphase - initial phase (optional)\n    \n    ; Create a table with harmonic ratios (1, 2, 3, 4, 5)\n    giRatios ftgen 10, 0, 8, -2, 1, 2, 3, 4, 5, 0, 0, 0\n    \n    ; Amplitude envelope\n    kAmp linseg 0, 0.1, 0.3, p3-0.2, 0.3, 0.1, 0\n    \n    ; Base frequency\n    kFreq = 110\n    \n    ; Generate 5 phasors at harmonic frequencies\n    aPhs1, aPhs2, aPhs3, aPhs4, aPhs5 phasorbnk kFreq, giRatios, 5\n    \n    ; Convert phasors to sine waves with decreasing amplitudes\n    aSig1 tablei aPhs1, giSine, 1\n    aSig2 tablei aPhs2, giSine, 1\n    aSig3 tablei aPhs3, giSine, 1\n    aSig4 tablei aPhs4, giSine, 1\n    aSig5 tablei aPhs5, giSine, 1\n    \n    ; Mix with harmonic weighting\n    aMix = aSig1 + aSig2*0.5 + aSig3*0.33 + aSig4*0.25 + aSig5*0.2\n    \n    out aMix * kAmp * 0.3\nendin\n\n</CsInstruments>\n<CsScore>\n\n; Play instrument 1 for 3 seconds\ni1 0 3\n\ne\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a CSound instrument that demonstrates the phasorbnk opcode for complex additive synthesis with time-varying harmonics", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac\n</CsOptions>\n<CsInstruments>\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n0dbfs = 1\n\n; Function table: sine wave\ngiSine ftgen 1, 0, 8192, 10, 1\n; Frequency ratios for bell-like timbre\ngiRatios ftgen 10, 0, 8, -2, 1, 2.76, 5.4, 8.93, 0, 0, 0, 0\n\ninstr 1\n    ; phasorbnk opcode: ares1 [, ares2] [, ...] phasorbnk xcps, kfn [, imax] [, ioffset] [, iphase]\n    ; Create a bell-like sound using inharmonic ratios\n    ; xcps - base frequency in Hz\n    ; kfn - function table with frequency ratios\n    ; imax - number of oscillators to use\n    \n    ; Base frequency\n    kFreq = 220\n    \n    ; Generate 4 phasors with inharmonic ratios\n    aPhs1, aPhs2, aPhs3, aPhs4 phasorbnk kFreq, giRatios, 4\n    \n    ; Different decay rates for each harmonic\n    kEnv1 expon 0.5, p3, 0.001\n    kEnv2 expon 0.4, p3*0.6, 0.001\n    kEnv3 expon 0.3, p3*0.4, 0.001\n    kEnv4 expon 0.2, p3*0.3, 0.001\n    \n    ; Convert to audio\n    aSig1 tablei aPhs1, giSine, 1\n    aSig2 tablei aPhs2, giSine, 1\n    aSig3 tablei aPhs3, giSine, 1\n    aSig4 tablei aPhs4, giSine, 1\n    \n    ; Apply individual envelopes\n    aMix = aSig1*kEnv1 + aSig2*kEnv2 + aSig3*kEnv3 + aSig4*kEnv4\n    \n    ; Stereo width\n    aLeft = aMix * 0.3\n    aRight = aMix * 0.3\n    \n    outs aLeft, aRight\nendin\n\n</CsInstruments>\n<CsScore>\n\n; Play bell-like tones\ni1 0 4\ni1 1 5 \ni1 2 6\n\ne\n</CsScore>\n</CsoundSynthesizer>"}
