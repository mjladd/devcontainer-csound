{"instruction": "Write a CSound instrument that demonstrates synthesis utility opcodes", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac\n</CsOptions>\n<CsInstruments>\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n0dbfs = 1\n\ngiSine ftgen 1, 0, 16384, 10, 1\ngiSaw ftgen 2, 0, 16384, 10, 1, 0.5, 0.3, 0.25, 0.2, 0.16\n\ninstr 1\n    ; balance opcode: ares balance asig, acomp [, ihp] [, iskip]\n    ; balance adjusts the RMS power of asig to match acomp\n    ; asig - signal to adjust\n    ; acomp - comparison signal (reference)\n    ; ihp - half-power point of internal filter\n    \n    iFreq = p4\n    \n    ; Reference signal (constant amplitude)\n    aRef poscil 0.5, iFreq, giSine\n    \n    ; Variable amplitude signal\n    kEnv linseg 0.1, p3*0.5, 0.8, p3*0.5, 0.2\n    aSig poscil kEnv, iFreq*1.5, giSaw\n    \n    ; Balance to match reference level\n    aBal balance aSig, aRef\n    \n    outs aBal*0.8, aBal*0.8\nendin\n\ninstr 2\n    ; follow opcode: ares follow asig, iatt, irel\n    ; follow generates envelope follower\n    ; asig - input signal\n    ; iatt - attack time\n    ; irel - release time\n    \n    iFreq = p4\n    \n    ; Input signal with varying amplitude\n    kAmp lfo 0.4, 3, 0\n    kAmp = 0.3 + kAmp\n    aIn poscil kAmp, iFreq, giSaw\n    \n    ; Envelope follower\n    iAtt = 0.01\n    iRel = 0.1\n    aEnv follow aIn, iAtt, iRel\n    \n    ; Use envelope to control another oscillator\n    aOut poscil aEnv*2, iFreq*2, giSine\n    \n    outs aOut, aOut\nendin\n\ninstr 3\n    ; follow2 opcode: ares follow2 asig, katt, krel\n    ; follow2 is like follow but with k-rate control\n    ; katt, krel - attack/release times (k-rate)\n    \n    iFreq = p4\n    \n    ; Input signal\n    kAmp lfo 0.3, 2, 0\n    kAmp = 0.4 + kAmp\n    aIn poscil kAmp, iFreq, giSaw\n    \n    ; Variable attack/release\n    kAtt linseg 0.001, p3, 0.05\n    kRel linseg 0.05, p3, 0.2\n    \n    aEnv follow2 aIn, kAtt, kRel\n    \n    ; Apply envelope\n    aOut poscil aEnv*2, iFreq*0.5, giSine\n    \n    outs aOut, aOut\nendin\n\ninstr 4\n    ; rms opcode: kres rms asig [, ihp] [, iskip]\n    ; rms calculates root-mean-square of signal\n    ; asig - input signal\n    ; ihp - half-power point\n    \n    iFreq = p4\n    \n    ; Signal with varying amplitude\n    kMod lfo 0.35, 2.5, 0\n    kMod = 0.4 + kMod\n    aSig poscil kMod, iFreq, giSaw\n    \n    ; Calculate RMS\n    kRMS rms aSig\n    \n    ; Use RMS to control filter\n    kCutoff = 500 + kRMS * 3000\n    aFilt butterlp aSig, kCutoff\n    \n    outs aFilt, aFilt\nendin\n\ninstr 5\n    ; gain opcode: ares gain asig, krms [, ihp] [, iskip]\n    ; gain adjusts signal to target RMS level\n    ; asig - input signal\n    ; krms - target RMS level\n    \n    iFreq = p4\n    \n    ; Signal with varying amplitude\n    kEnv linseg 0.2, p3*0.3, 0.9, p3*0.7, 0.1\n    aSig poscil kEnv, iFreq, giSaw\n    \n    ; Target RMS level\n    kTarget = 0.3\n    \n    ; Apply gain to maintain target level\n    aGain gain aSig, kTarget\n    \n    outs aGain, aGain\nendin\n\n</CsInstruments>\n<CsScore>\n\n; Play balance\ni1 0 3 330\n\n; Play follow\ni2 4 4 440\n\n; Play follow2\ni3 9 4 294\n\n; Play rms\ni4 14 4 523\n\n; Play gain\ni5 19 3 392\n\ne\n</CsScore>\n</CsoundSynthesizer>"}
{"instruction": "Write a CSound instrument that demonstrates advanced utility techniques", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac\n</CsOptions>\n<CsInstruments>\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n0dbfs = 1\n\ngiSine ftgen 1, 0, 16384, 10, 1\ngiSaw ftgen 2, 0, 16384, 10, 1, 0.5, 0.3, 0.25, 0.2, 0.16\n\ninstr 1\n    ; Side-chain compression using follow\n    iFreq1 = p4\n    iFreq2 = p5\n    \n    ; Main signal\n    aMain poscil 0.5, iFreq1, giSaw\n    \n    ; Side-chain signal\n    kKick lfo 0.6, 2, 2\n    kKick = 0.3 + kKick\n    aSide poscil kKick, iFreq2, giSine\n    \n    ; Extract envelope from side-chain\n    aEnv follow aSide, 0.001, 0.1\n    \n    ; Duck main signal based on side-chain\n    kDuck = 1 - aEnv * 1.5\n    kDuck limit kDuck, 0, 1\n    \n    aOut = aMain * kDuck + aSide\n    \n    outs aOut, aOut\nendin\n\ninstr 2\n    ; Dynamic balancing\n    iFreq = p4\n    \n    ; Two sources with different characteristics\n    aSource1 poscil 0.4, iFreq, giSine\n    \n    kEnv linseg 0.1, p3*0.5, 0.8, p3*0.5, 0.1\n    aSource2 poscil kEnv, iFreq*2, giSaw\n    \n    ; Balance second source to first\n    aBal balance aSource2, aSource1\n    \n    ; Mix\n    aMix = aSource1 * 0.5 + aBal * 0.5\n    \n    outs aMix, aMix\nendin\n\ninstr 3\n    ; RMS-based dynamics\n    iFreq = p4\n    \n    ; Complex source\n    aOsc1 poscil 0.3, iFreq, giSaw\n    aOsc2 poscil 0.2, iFreq*1.5, giSaw\n    aMix = aOsc1 + aOsc2\n    \n    ; Calculate RMS\n    kRMS rms aMix\n    \n    ; Compress based on RMS\n    kComp = 1\n    if kRMS > 0.4 then\n        kComp = 0.4 / kRMS\n    endif\n    \n    aOut = aMix * kComp\n    \n    outs aOut, aOut\nendin\n\n</CsInstruments>\n<CsScore>\n\n; Play side-chain compression\ni1 0 5 330 55\n\n; Play dynamic balancing\ni2 6 4 440\n\n; Play RMS compression\ni3 11 4 294\n\ne\n</CsScore>\n</CsoundSynthesizer>"}
