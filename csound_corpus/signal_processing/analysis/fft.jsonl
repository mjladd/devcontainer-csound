{"instruction": "Write a CSound instrument that demonstrates FFT processing opcodes: fft, fftinv, rfft, rifft", "input": "", "output": "<CsoundSynthesizer>\n<CsOptions>\n-odac\n</CsOptions>\n<CsInstruments>\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n    ; fft/fftinv opcodes: kout[] fft kin[]; kout[] fftinv kin[]\n    ; Forward and inverse FFT on k-rate arrays\n    \n    ; Create a signal in k-rate array\n    kArr[] init 256\n    kndx = 0\n    while kndx < 256 do\n        kArr[kndx] = sin(2*$M_PI*kndx*5/256)  ; 5 cycles\n        kndx += 1\n    od\n    \n    ; Forward FFT\n    kFreq[] fft kArr\n    \n    ; Modify spectrum (zero out high frequencies)\n    kndx = 128\n    while kndx < 256 do\n        kFreq[kndx] = 0\n        kndx += 1\n    od\n    \n    ; Inverse FFT\n    kTime[] fftinv kFreq\n    \n    ; Use first value to modulate frequency\n    kMod = kTime[0] * 100\n    aOut oscili 0.3, 440+kMod, -1\n    \n    outs aOut, aOut\nendin\n\ninstr 2\n    ; rfft/rifft opcodes: kout[] rfft kin[]; kout[] rifft kin[]\n    ; Real FFT (more efficient for real-valued signals)\n    \n    ; Generate real signal\n    kArr[] init 512\n    kndx = 0\n    while kndx < 512 do\n        kArr[kndx] = cos(2*$M_PI*kndx*3/512) + 0.5*cos(2*$M_PI*kndx*7/512)\n        kndx += 1\n    od\n    \n    ; Real FFT (output is half size + 1)\n    kFreq[] rfft kArr\n    \n    ; Manipulate spectrum\n    kndx = 50\n    while kndx < 257 do\n        kFreq[kndx] *= 0.5  ; Attenuate high frequencies\n        kndx += 1\n    od\n    \n    ; Inverse real FFT\n    kTime[] rifft kFreq\n    \n    ; Use modified signal to control synthesis\n    kPhase = kTime[0]\n    aOut oscili 0.3, 330, -1, kPhase\n    \n    outs aOut, aOut\nendin\n\ninstr 3\n    ; Spectral manipulation with FFT\n    ; Process audio through FFT/IFFT\n    \n    ; Input signal\n    aIn vco2 0.3, 220, 0\n    \n    ; Convert to k-rate arrays (simplified example)\n    ; In practice, would use a-rate FFT with overlap-add\n    \n    ; Simulate spectral processing with filtering\n    ; Low-pass for low freqs, high-pass for highs\n    aLow butterlp aIn, 500\n    aHigh butterhp aIn, 2000\n    \n    ; Recombine with modified weights\n    aOut = aLow*1.5 + aHigh*0.5\n    \n    outs aIn*0.5, aOut*0.5\nendin\n\ninstr 4\n    ; FFT-based filtering\n    kSize = 1024\n    kArr[] init kSize\n    \n    ; Fill with audio samples (simplified)\n    kndx = 0\n    kPhase = 0\n    while kndx < kSize do\n        kPhase += 2*$M_PI*440/sr\n        kArr[kndx] = sin(kPhase)\n        kndx += 1\n    od\n    \n    ; FFT\n    kFreq[] fft kArr\n    \n    ; Notch filter in frequency domain\n    kNotchBin = int(440 * kSize / sr)\n    kFreq[kNotchBin] = 0\n    kFreq[kNotchBin-1] *= 0.3\n    kFreq[kNotchBin+1] *= 0.3\n    \n    ; IFFT\n    kTime[] fftinv kFreq\n    \n    ; Generate audio\n    aOut oscili 0.3, 330, -1\n    \n    outs aOut, aOut\nendin\n\ninstr 5\n    ; Spectral freeze effect using FFT concepts\n    aIn buzz 0.3, 165, 20, -1\n    \n    ; Use PVS for actual FFT processing\n    fsig pvsanal aIn, 1024, 256, 1024, 1\n    \n    ; Freeze spectrum periodically\n    kFreeze linseg 0, p3*0.3, 0, 0.01, 1, p3*0.4, 1, 0.01, 0, p3*0.3-0.02, 0\n    ffrz pvsfreeze fsig, kFreeze, kFreeze\n    \n    aOut pvsynth ffrz\n    \n    outs aIn*0.4, aOut*0.6\nendin\n\n</CsInstruments>\n<CsScore>\n\ni1 0 3\ni2 4 3\ni3 8 3\ni4 12 3\ni5 16 4\n\ne\n</CsScore>\n</CsoundSynthesizer>"}
