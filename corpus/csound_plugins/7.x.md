---
source: Csound Plugins Repository
plugin: 7.x
path: 7.x
type: csound_plugin
opcode_count: 85
example_count: 33
---

# 7.x

**Source Path:** `7.x`
**Opcodes:** 85
**Examples:** 33

## Description

Plugins for Csound 7.x =======

## Opcodes

- `pyinit`
- `pyrun`
- `pyruni`
- `pylrun`
- `pylruni`
- `pyrunt`
- `pylrunt`
- `pyexec`
- `pyexeci`
- `pylexec`
- `pylexeci`
- `pyexect`
- `pylexect`
- `pycall`
- `pycall1`
- `pycall2`
- `pycall3`
- `pycall4`
- `pycall5`
- `pycall6`
- `pycall7`
- `pycall8`
- `pycalln`
- `pycallt`
- `pycall1t`
- `pycall2t`
- `pycall3t`
- `pycall4t`
- `pycall5t`
- `pycall6t`
- `pycall7t`
- `pycall8t`
- `pycallnt`
- `pycalli`
- `pycall1i`
- `pycall2i`
- `pycall3i`
- `pycall4i`
- `pycall5i`
- `pycall6i`
- `pycall7i`
- `pycall8i`
- `pycallni`
- `pylcall`
- `pylcall1`
- `pylcall2`
- `pylcall3`
- `pylcall4`
- `pylcall5`
- `pylcall6`
- `pylcall7`
- `pylcall8`
- `pylcalln`
- `pylcallt`
- `pylcall1t`
- `pylcall2t`
- `pylcall3t`
- `pylcall4t`
- `pylcall5t`
- `pylcall6t`
- `pylcall7t`
- `pylcall8t`
- `pylcallnt`
- `pylcalli`
- `pylcall1i`
- `pylcall2i`
- `pylcall3i`
- `pylcall4i`
- `pylcall5i`
- `pylcall6i`
- `pylcall7i`
- `pylcall8i`
- `pylcallni`
- `pyeval`
- `pyevali`
- `pyleval`
- `pylevali`
- `pyevalt`
- `pylevalt`
- `pyassign`
- `pyassigni`
- `pylassign`
- `pylassigni`
- `pyassignt`
- `pylassignt`

## Examples

### python0

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac -m0
</CsOptions>
<CsInstruments>

sr=44100
ksmps=128
nchnls=2

pyinit ;Start python interpreter

pyruni "print(44100)"

instr 1
endin


</CsInstruments>
<CsScore>
i 1 0 0.1
</CsScore>
</CsoundSynthesizer>
```

### python1

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac -m0
</CsOptions>
<CsInstruments>

sr=44100
ksmps=128
nchnls=2

pyinit ;Start python interpreter

pyruni {{
a = 2
b = 3
print("a + b = " + str(a+b))
}} ;Execute a python script on the header

instr 1
pyruni {{a = 6
b = 5
print("a + b = " + str(a+b))}}
endin


instr 2
pyruni {{print("a + b = " + str(a+b))}}
endin


</CsInstruments>
<CsScore>

i 1 0 0.1
i 2 1 0.1
</CsScore>
</CsoundSynthesizer>
```

### python2

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac -m0
</CsOptions>
<CsInstruments>

sr=44100
kr=100
nchnls=2

pyinit

pyruni "a = 0"

instr 1
    pyrun "a = a + 1"
endin


instr 2
    pyruni {{print("a = " + str(a))}}
endin


</CsInstruments>
<CsScore>

i 1 0 1    ;Adds to a for 1 second
i 2 1 0.1  ;Prints a
i 1 2 1    ;Adds to a for another second
i 2 3 0.1  ;Prints a

</CsScore>
</CsoundSynthesizer>
```

### python3

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac -m0
</CsOptions>
<CsInstruments>

sr=44100
kr=100
nchnls=2

pyinit

pyruni "a = 0.0"

instr 1
    pyrun "a = a + 1"
endin


instr 2
ival pyevali "a"
prints "a = %i\\n", ival
endin


</CsInstruments>
<CsScore>

i 1 0 1    ;Adds to a for 1 second
i 2 1 0.1  ;Prints a
i 1 2 1    ;Adds to a for another second
i 2 3 0.1  ;Prints a

</CsScore>
</CsoundSynthesizer>
```

### python4

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac -m0
</CsOptions>
<CsInstruments>

sr=44100
kr=100
nchnls=2

pyinit

pyassigni "a", 0

instr 1
    pyrun "a = a + 1"
endin


instr 2
ival pyevali "a"
prints "a = %i\\n", ival
endin


</CsInstruments>
<CsScore>

i 1 0 1    ;Adds to a for 1 second
i 2 1 0.1  ;Prints a
i 1 2 1    ;Adds to a for another second
i 2 3 0.1  ;Prints a

</CsScore>
</CsoundSynthesizer>
```

### python5

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac -m0
</CsOptions>
<CsInstruments>

sr=44100
kr=100
nchnls=2

pyinit

pyruni {{
def average(a,b):
    ave = (a + b)/2
    return ave
}} ;Define function "average"

instr 1
iave   pycall1i "average", p4, p5
prints "a = %i\\n", iave
endin


</CsInstruments>
<CsScore>

i 1 0 1  100  200
i 1 1 1  1000 2000

</CsScore>
</CsoundSynthesizer>
```

### pythonlocal

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac -m0
</CsOptions>
<CsInstruments>

gkprint init 0

instr 1
ivalue init p4
ktrig changed gkprint
if (ktrig == 1) then
  printk 0.5, ivalue
endif
endin

instr 2
gkprint init 1
endin

</CsInstruments>

<CsScore>
;          p4
i 1 0 5   100
i 1 1 5   200
i 1 2 5   300
i 1 3 5   400

i 2 3 1
</CsScore>
</CsoundSynthesizer>

```

### pythonlocal2

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac -m0
</CsOptions>
<CsInstruments>

pyinit

gkprint init 0

instr 1
;assign 4th p-field to local python variable "value"
pylassigni "value", p4
ktrig changed gkprint

; If gkprint has changed (i.e. instr 2 was triggered)
; print the value of the local python variable "value"
if (ktrig == 1) then
  kvalue pyleval "value"
  printk 0.5, kvalue
endif
endin

instr 2
gkprint init 1
endin

</CsInstruments>

<CsScore>
;          p4
i 1 0 5   100
i 1 1 5   200
i 1 2 5   300
i 1 3 5   400

i 2 3 1
</CsScore>
</CsoundSynthesizer>

```

### pythonmarkov

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac
</CsOptions>
<CsInstruments>

sr=44100
ksmps=128
nchnls=2

pyinit

; Python script to define probabilities for each note as lists within a list
; Definition of the get_new_note function which randomly generates a new
; note based on the probabilities of each note occuring.
; Each note list must total 1, or there will be problems!

pyruni {{c = [0.1, 0.2, 0.05, 0.4, 0.25]
d = [0.4, 0.1, 0.1, 0.2, 0.2]
e = [0.2, 0.35, 0.05, 0.4, 0]
g = [0.7, 0.1, 0.2, 0, 0]
a = [0.1, 0.2, 0.05, 0.4, 0.25]

markov = [c, d, e, g, a]

import random

random.seed()

def get_new_note(previous_note):
    number = random.random()
    accum = 0
    i = 0
    while accum < number:
        accum = accum + markov[int(previous_note)][int(i)]
        i = i + 1
    return i - 1.0

}}



instr 1  ;Markov chain reader and note spawner
;p4 = frequency of note generation
;p5 = octave
ioct init p5
klastnote init 0 ;Used to remember last note played (start at first note of scale)
ktrig metro p4 ;generate a trigger with frequency p4
knewnote pycall1t ktrig, "get_new_note", klastnote ;get new note from chain
schedkwhen ktrig, 0, 10, 2, 0, 0.2, knewnote, ioct ;launch note on instrument 2
klastnote = knewnote ;New note is now the old note
endin


instr 2 ;A simple sine wave instrument
;p4 = note to be played
;p5 = octave
ioct init p5
ipclass table p4, 2
ipclass = ioct + (ipclass / 100) ; Pitch class of the note
ifreq = cpspch(ipclass) ;Note frequency in Hertz
aenv linen 6000, 0.05, p3, 0.1 ;Amplitude envelope
aout oscil  aenv, ifreq , 1 ;Simple oscillator
outs aout, aout
endin


</CsInstruments>
<CsScore>

f 1 0 2048 10 1 ;sine wave
f 2 0 8  -2  0  2  4  7 9  ;Pitch classes for pentatonic scale

;        frequency of       Octave of
;        note generation    melody
i 1 0 30      3               7
i 1 5 25      6               9
i 1 10 20     7.5             10
i 1 15 15     1               8

</CsScore>
</CsoundSynthesizer>
```

### embeddedCtcsound

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac
</CsOptions>
<CsInstruments>

sr     = 48000
ksmps  = 100
nchnls = 2

pyinit ;Start python interpreter

pyruni {{
import ctcsound
import sys

# Get an opaque pointer to the running Csound instance
# and print Python version number
p = _CSOUND_
print("\\n  --> Python version number: {}\\n".format(sys.version_info[0]))
# Create an object called cs from the ctcsound.Csound class
# using the opaque pointer to the Csound instance
cs = ctcsound.Csound(pointer_=p)
}}

instr 1
  ; Use the cs python object
  pyruni {{
print("\\n  --> Sample Rate: {}, Control Rate: {}\\n".format(cs.sr(), cs.kr()))
  }}
endin

</CsInstruments>
<CsScore>
i1 0 1
</CsScore>
</CsoundSynthesizer>


```

### ievent

```csound
sr=44100
kr=4410
ksmps=10
nchnls=2

giSinusoid      ftgen           0,      0, 8192, 10,    1

pyinit

pyruni  {{
import ctcsound
import sys
from random import random
p = _CSOUND_
print("\\n  --> Python version number: {}\\n".format(sys.version_info[0]))
cs = ctcsound.Csound(pointer_=p)
for i in range(800):
        cs.event(ctcsound.CS_INSTR_EVENT, [1, i*0.2, 0.05, 6.8 + random()*3, 70.0])
        cs.event(ctcsound.CS_INSTR_EVENT, [1, i*0.2, 0.05, 8.8 + random()*3, 70.0])
}}

instr 1

        iDuration       =       p3
        iFrequency      =       cpsoct(p4)
        iAmplitude      =       ampdb(p5)

        aAmplitude      linseg  iAmplitude, iDuration - 0.01, iAmplitude, 0.002 ,0, 1,0
        aOutput         oscili  aAmplitude, iFrequency, giSinusoid

                        outs    aOutput, aOutput

endin

```

### ievent

```csound
f0 60

```

### pyassign

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

pyinit

instr 1

        k1      rand            1000
                pyassign        "a", k1
                pyrun           "print(a)"
endin

```

### pyassign

```csound
i1 0 0.01

```

### pycall1

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

giSinusoid      ftgen   0,      0, 8192, 10,    1

pyinit

pyruni {{
import random

pool = [(1 + i/10.0) ** 1.2 for i in range(100)]

def get_number_from_pool(n, p):
    if random.random() < p:
        i = int(random.random() * len(pool))
        pool[i] = n

    return random.choice(pool)
}}

instr 1

        k1      oscil   1, 3, giSinusoid

        k2      pycall1 "get_number_from_pool", k1 + 2, p4

                printk  0.01, k2

endin

```

### pycall1

```csound
i1 0 10 0.01

```

### pycall2

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

giSinusoid      ftgen   0,      0, 8192, 10,    1

pyinit

pyruni {{
import random

class GetNumberFromPool:
    def __init__(self, e=1.2, a=1.0, f=0.1, N=100):
        self.pool = [(a + i*f) ** e for i in range(N)]

    def __call__(self, n, p):
        if random.random() < p:
            i = int(random.random() * len(self.pool))
            self.pool[i] = n

        return random.choice(self.pool)

get_number_from_pool = GetNumberFromPool()
}}

instr 1

        k1      oscil   1, 3, giSinusoid

        k2      pycall1 "get_number_from_pool", k1 + 2, p4

                printk  0.01, k2

endin

```

### pycall2

```csound
i1 0 10 0.01

```

### pycall3

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

pyinit

pyruni  {{
def f0(a, b, c, d, e, f, g, h):
    pass

def f1(a, b, c, d, e, f, g, h):
    return a

def f2(a, b, c, d, e, f, g, h):
    return a, b

def f3(a, b, c, d, e, f, g, h):
    return a, b, c

def f4(a, b, c, d, e, f, g, h):
    return a, b, c, d

def f5(a, b, c, d, e, f, g, h):
    return a, b, c, d, e

def f6(a, b, c, d, e, f, g, h):
    return a, b, c, d, e, f

def f7(a, b, c, d, e, f, g, h):
    return a, b, c, d, e, f, g

def f8(a, b, c, d, e, f, g, h):
    return a, b, c, d, e, f, g, h
}}

instr 1

                                 pycall  "f0", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1                             pycall1 "f1", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2                         pycall2 "f2", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3                     pycall3 "f3", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4                 pycall4 "f4", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4, k5             pycall5 "f5", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4, k5, k6         pycall6 "f6", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4, k5, k6, k7     pycall7 "f7", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4, k5, k6, k7, k8 pycall8 "f8", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8

        printk  0.01, k1
        printk  0.01, k2
        printk  0.01, k3
        printk  0.01, k4
        printk  0.01, k5
        printk  0.01, k6
        printk  0.01, k7
        printk  0.01, k8
endin

```

### pycall3

```csound
i1 0 0.1

```

### pycallt

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

pyinit

pyruni  {{
def f0(a, b, c, d, e, f, g, h):
    print('f0 got', a, b, c, d, e, f, g, h)
    print('f0 returning None')

def f1(a, b, c, d, e, f, g, h):
    print('f1 got', a, b, c, d, e, f, g, h)
    print('f1 returning', a)
    return a

def f2(a, b, c, d, e, f, g, h):
    print('f2 got', a, b, c, d, e, f, g, h)
    print('f2 returning', a, b)
    return a, b

def f3(a, b, c, d, e, f, g, h):
    print('f3 got', a, b, c, d, e, f, g, h)
    print('f3 returning', a, b, c)
    return a, b, c

def f4(a, b, c, d, e, f, g, h):
    print('f4 got', a, b, c, d, e, f, g, h)
    print('f4 returning', a, b, c, d)
    return a, b, c, d

def f5(a, b, c, d, e, f, g, h):
    print('f5 got', a, b, c, d, e, f, g, h)
    print('f5 returning', a, b, c, d, e)
    return a, b, c, d, e

def f6(a, b, c, d, e, f, g, h):
    print('f6 got', a, b, c, d, e, f, g, h)
    print('f6 returning', a, b, c, d, e, f)
    return a, b, c, d, e, f

def f7(a, b, c, d, e, f, g, h):
    print('f7 got', a, b, c, d, e, f, g, h)
    print('f7 returning', a, b, c, d, e, f, g)
    return a, b, c, d, e, f, g

def f8(a, b, c, d, e, f, g, h):
    print('f8 got', a, b, c, d, e, f, g, h)
    print('f8 returning', a, b, c, d, e, f, g, h)
    return a, b, c, d, e, f, g, h
}}

instr 1

        kt      metro   1.5

                                 pycallt  kt, "f0", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1                             pycall1t kt, "f1", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2                         pycall2t kt, "f2", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3                     pycall3t kt, "f3", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4                 pycall4t kt, "f4", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4, k5             pycall5t kt, "f5", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4, k5, k6         pycall6t kt, "f6", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4, k5, k6, k7     pycall7t kt, "f7", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4, k5, k6, k7, k8 pycall8t kt, "f8", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
endin

```

### pycallt

```csound
i1 0 10

```

### pyeval

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

        pyinit

        pyruni  "from random import random"

instr 1

                pyrun   "a = random()"
        k1      pyeval  "a"
                printk  0.1, k1
endin

```

### pyeval

```csound
i1 0 0.5

```

### pyexec

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

        pyinit

        pyruni "import random"

        pyexeci "pyexec1.py"

instr 1

        pyexec          "pyexec2.py"

        pylexeci        "pyexec3.py"
        pylexec         "pyexec4.py"

endin

```

### pyexec

```csound
i1 0 0.01
i1 0 0.01

```

### pyexect

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

pyinit

instr 1

        ktrigger1       metro           3
        ktrigger2       metro           6
        ktrigger3       metro           10
        ktrigger4       metro           0.5

        pyexect         ktrigger1, "pyexect1.py"
        pyexect         ktrigger2, "pyexect2.py"
        pyexect         ktrigger3, "pyexect3.py"

        pylexect        ktrigger3 + ktrigger1, "pyexect4.py"

        a1              rand            5000

                        out             a1

endin

```

### pyexect

```csound
i1 0 5
i1 0 5

```

### pyrun

```csound
<CsoundSynthesizer>
<CsOptions>
 -odac
</CsOptions>
<CsInstruments>
sr=44100
kr=4410
ksmps=10
nchnls=1

pyinit

pyruni "import random"

instr 1
        ; This message is stored in the main namespace
        ; and is the same for every instance
        pyruni  "message = 'a global random number: %f' % random.random()"
        pyrun   "print(message)"

        ; This message is stored in the private namespace
        ; and is different for different instances
        pylruni "message = 'a private random number: %f' % random.random()"
        pylrun  "print(message)"

endin
</CsInstruments>
<CsScore>
i1 0 0.01
</CsScore>
</CsoundSynthesizer>

```

### pyrun

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

pyinit

pyruni "import random"

instr 1
        ; This message is stored in the main namespace
        ; and is the same for every instance
        pyruni  "message = 'a global random number: %f' % random.random()"
        pyrun   "print(message)"

        ; This message is stored in the private namespace
        ; and is different for different instances
        pylruni "message = 'a private random number: %f' % random.random()"
        pylrun  "print(message)"
endin

```

### pyrun

```csound
i1 0 0.1

```

### pyrunt

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

pyinit

instr 1

        ktrigger1       metro           3
        ktrigger2       metro           6
        ktrigger3       metro           10

        pyrunt          ktrigger1, "print('zum')"
        pyrunt          ktrigger2, "print('pa')"
        pyrunt          ktrigger3, "print('zi')"

        pylrunt         ktrigger3 + ktrigger1, "print('zut')"

        a1              rand            5000

                        out             a1
endin

```

### pyrunt

```csound
i1 0 5
i1 0 5

```

## Full Documentation

Plugins for Csound 7.x
=======

Currently, the plugins available in this tree are

- py (requires a Python 3.x installation with dev libs)
**Many opcodes to call Python code**


Install location
--------------
The CMake scripts in this repository use the default CS_USER_PLUGIN
location on MacOS and Windows as defined in the Csound build, or a
library instalation directory (customisable) on LINUX. These are:

- LINUX: depends on both `CMAKE_INSTALL_PREFIX` and `USE_LIB64`. It is then installed in:
   * if `USE_LIB64=1` then to
       * for doubles: `${CSOUND_INSTALL_PREFIX}/lib64/csound/plugins64-${APIVERSION}`
       * for floats: `${CSOUND_INSTALL_PREFIX}/lib64/csound/plugins-${APIVERSION}` (floats)`
   * if `USE_LIB64=0` then to
       * for doubles: `${CSOUND_INSTALL_PREFIX}/lib/csound/plugins64-${APIVERSION}`
       * for floats: `${CSOUND_INSTALL_PREFIX}/lib/csound/plugins-${APIVERSION}`

- MACOS:
    * For doubles: `$HOME/Library/csound/${APIVERSION}/plugins64`
    * For floats: `$HOME/Library/csound/${APIVERSION}/plugins`
- Windows:
    * For doubles: `%LOCALAPPDATA%\csound\${APIVERSION}\plugins64`
    * For floats: `%LOCALAPPDATA%\csound\${APIVERSION}\plugins`


Build Instructions for Linux and MacOS
---

The build requires Csound to be installed, as well as CMake. With this
in place, you can do :

```
$ git clone https://github.com/csound/plugins.git
$ cd plugins
$ mkdir build
$ cd build
$ cmake ../
$ make
```

By default, all the plugins are built. If one wants to exclude a
plugin from the build process, one can pass an option to the cmake command.
For example, to exclude the XXX plugin, the `cmake` command would be:

```
$ cmake -DXXX_OPCODES=OFF ../
```


To install the opcodes you have built

```
$ make install
```

Depending on your permissions, you might need to prepend `sudo` to
these commands. After the first build the plugins can be updated with

```
$ git pull
$ make
$ make install
```

using `sudo` in the last step if raised permissions are needed. On
Linux, the installation location can be set with the relevant CMake
variables as indicated above.

Csound Location
------------
CMake will normally find the installed Csound headers (and library)
automatically. However, if your Csound headers and library are not
placed in the usual locations, you can use the following CMake option variables
to tell CMake where they are:

```
CSOUND_INCLUDE_DIR_HINT
```
and

```
CSOUND_LIBRARY_DIR_HINT
