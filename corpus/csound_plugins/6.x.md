---
source: Csound Plugins Repository
plugin: 6.x
path: 6.x
type: csound_plugin
opcode_count: 179
example_count: 42
---

# 6.x

**Source Path:** `6.x`
**Opcodes:** 179
**Examples:** 42

## Description

Plugins for Csound 6.x =======

## Opcodes

- `faustgen`
- `faustcompile`
- `faustaudio`
- `faustdsp`
- `faustplay`
- `STRING_VAR`
- `imageload`
- `imagecreate`
- `imagesize`
- `imagegetpixel`
- `imagesetpixel`
- `imagesave`
- `imagefree`
- `jacktransport`
- `mp3out`
- `cladsyn`
- `p5gconnect`
- `p5gdata`
- `pyinit`
- `pyrun`
- `pyruni`
- `pylrun`
- `pylruni`
- `pyrunt`
- `pylrunt`
- `pyexec`
- `pyexeci`
- `pylexec`
- `pylexeci`
- `pyexect`
- `pylexect`
- `pycall`
- `pycall1`
- `pycall2`
- `pycall3`
- `pycall4`
- `pycall5`
- `pycall6`
- `pycall7`
- `pycall8`
- `pycalln`
- `pycallt`
- `pycall1t`
- `pycall2t`
- `pycall3t`
- `pycall4t`
- `pycall5t`
- `pycall6t`
- `pycall7t`
- `pycall8t`
- `pycallnt`
- `pycalli`
- `pycall1i`
- `pycall2i`
- `pycall3i`
- `pycall4i`
- `pycall5i`
- `pycall6i`
- `pycall7i`
- `pycall8i`
- `pycallni`
- `pylcall`
- `pylcall1`
- `pylcall2`
- `pylcall3`
- `pylcall4`
- `pylcall5`
- `pylcall6`
- `pylcall7`
- `pylcall8`
- `pylcalln`
- `pylcallt`
- `pylcall1t`
- `pylcall2t`
- `pylcall3t`
- `pylcall4t`
- `pylcall5t`
- `pylcall6t`
- `pylcall7t`
- `pylcall8t`
- `pylcallnt`
- `pylcalli`
- `pylcall1i`
- `pylcall2i`
- `pylcall3i`
- `pylcall4i`
- `pylcall5i`
- `pylcall6i`
- `pylcall7i`
- `pylcall8i`
- `pylcallni`
- `pyeval`
- `pyevali`
- `pyleval`
- `pylevali`
- `pyevalt`
- `pylevalt`
- `pyassign`
- `pyassigni`
- `pylassign`
- `pylassigni`
- `pyassignt`
- `pylassignt`
- `FLvkeybd`
- `FLslider`
- `FLslidBnk`
- `FLknob`
- `FLroller`
- `FLtext`
- `FLjoy`
- `FLcount`
- `FLbutton`
- `FLbutBank`
- `FLkeyb`
- `FLcolor`
- `FLcolor2`
- `FLlabel`
- `FLsetVal_i`
- `FLsetVali`
- `FLsetVal`
- `FLsetColor`
- `FLsetColor2`
- `FLsetTextSize`
- `FLsetTextColor`
- `FLsetFont`
- `FLsetTextType`
- `FLsetText`
- `FLsetSize`
- `FLsetPosition`
- `FLhide`
- `FLshow`
- `FLsetBox`
- `FLsetAlign`
- `FLbox`
- `FLvalue`
- `FLpanel`
- `FLpanelEnd`
- `FLpanel_end`
- `FLscroll`
- `FLscrollEnd`
- `FLscroll_end`
- `FLpack`
- `FLpackEnd`
- `FLpack_end`
- `FLtabs`
- `FLtabsEnd`
- `FLtabs_end`
- `FLgroup`
- `FLgroupEnd`
- `FLgroup_end`
- `FLsetsnap`
- `FLsetSnapGroup`
- `FLgetsnap`
- `FLsavesnap`
- `FLloadsnap`
- `FLrun`
- `FLupdate`
- `FLprintk`
- `FLprintk2`
- `FLcloseButton`
- `FLexecButton`
- `FLkeyIn`
- `FLxyin`
- `FLmouse`
- `FLvslidBnk`
- `FLslidBnk2`
- `FLvslidBnk2`
- `FLslidBnkGetHandle`
- `FLslidBnkSet`
- `FLslidBnkSetk`
- `FLslidBnk2Set`
- `FLslidBnk2Setk`
- `FLhvsBox`
- `FLhvsBoxSetValue`
- `FLmeter`
- `wiiconnect`
- `wiidata`
- `wiisend`
- `wiirange`

## Examples

### cuda_pvs_example

```csound
<CsoundSynthesizer>
<CsOptions>
;--opcode-lib=./libcudaop2.dylib
</CsOptions>
<CsInstruments>

ksmps = 64
0dbfs = 1

instr 1
ifftsize = 4096
ihopsize = 512
asig = diskin2:a("flutec3.wav",1,0,1)
fsig = cudanal(asig,
               ifftsize,
               ihopsize,
               ifftsize, 1)
asig = cudasynth(fsig)
asig = linenr(asig,0.005,0.01,0.01)
   out(asig)
endin

instr 2
S1 = "flutec3.wav"
ifftsize = 32768
ihopsize = 512
asig  diskin2 S1, 1, 0, 1
fsig pvsanal asig, ifftsize, ihopsize, ifftsize, 1
a1 pvsynth fsig
a2 linenr a1*0.5,0.005,0.01,0.01
   out a2
endin


</CsInstruments>
<CsScore>
i1 0 60
</CsScore>
</CsoundSynthesizer>


```

### cuda_sliding_example

```csound
<CsoundSynthesizer>
<CsOptions>
--opcode-lib=./libcudaop3.dylib
</CsOptions>
<CsInstruments>

ksmps = 64
0dbfs = 1

instr 1
asig,adp diskin "metheny.wav",1,0,1
amod = p4; oscil:a(2,3)
asig2 = cudasliding(asig,amod,p5)
asig = linenr(asig2,0.005,0.01,0.01)
   out(asig*0.5)
endin

</CsInstruments>
<CsScore>
i1 0 60 1 512
;i1 0 5 0.5 1024
</CsScore>
</CsoundSynthesizer>


```

### cudaconv

```csound
<CsoundSynthesizer>
<CsOptions>
--opcode-lib=libcudaop4.dylib
</CsOptions>
<CsInstruments>
ksmps = 128
i1 ftgen  1,0,1024,1,"/Users/victor/audio/church.wav",0,0,1

instr 1

asig diskin2 "/Users/victor/audio/cornetto.wav",1,01
a1 cudaconv asig,1
;a1 dconv asig,ftlen(1),1
    out a1/20
endin

</CsInstruments>
<CsScore>
i1 0 10
</CsScore>
</CsoundSynthesizer>


```

### cudadsyn_pvs_example

```csound
<CsoundSynthesizer>
<CsOptions>
--opcode-lib=./libcudaop1.dylib --opcode-lib=./libcudaop2.dylib
</CsOptions>
<CsInstruments>

ksmps = 64
0dbfs = 1

instr 1
ifftsize = 2048
ihopsize = 512
ibins = 1024
asig1,adp diskin "/users/victor/audio/metheny.wav",1,0,1
fsig = pvsanal(asig1, ifftsize,ihopsize, ifftsize, 1)
asig = cudasynth(fsig,1,1,ibins)
asig = linenr(asig,0.001,0.01,0.01)
    out(asig*0.5)

endin

instr 2
ifftsize = 2048
ihopsize = 512
ibins = 1024
asig1,adp diskin "/users/victor/audio/metheny.wav",1,0,1
fsig = pvsanal(asig1, ifftsize,ihopsize, ifftsize, 1)
asig = pvsadsyn(fsig,ibins,1)
asig = linenr(asig,0.001,0.01,0.01)
    out(asig*0.5)

endin

</CsInstruments>
<CsScore>
i1 0 60
</CsScore>
</CsoundSynthesizer>


```

### cudapconv

```csound
<CsoundSynthesizer>
<CsOptions>
</CsOptions>
<CsInstruments>
ksmps = 8
nchnls =2
i1 ftgen  1,0,0,1,"church.wav",0,0,1
i2 ftgen  2,0,64,1,"church.wav",0,0,1
;i1 ftgen  1,0,65536,7,1,1,1,0,65534,0
i1 ftgen  1,0,0,1,"/Users/victor/audio/metheny.wav",0,0,1
instr 1

;asig oscili 0dbfs/4, 440;

asig diskin2 "/Users/victor/audio/cornetto.wav",1,0,1
a1 cudapconv asig,1,16384
;a2 cudaconv asig,2
;a1 ftconv asig,1,64
;a1 pconvolve asig,"/Users/victor/audio/church_00.wav",1024
    out a1/500, a1/500
endin

</CsInstruments>
<CsScore>
i1 0 60
</CsScore>
</CsoundSynthesizer>

<bsbPanel>
 <label>Widgets</label>
 <objectName/>
 <x>100</x>
 <y>100</y>
 <width>320</width>
 <height>240</height>
 <visible>true</visible>
 <uuid/>
 <bgcolor mode="nobackground">
  <r>255</r>
  <g>255</g>
  <b>255</b>
 </bgcolor>
</bsbPanel>
<bsbPresets>
</bsbPresets>

```

### test

```csound
<CsoundSynthesizer>

<CsOptions>

</CsOptions>

<CsInstruments>
sr=44100
kr=441
ksmps=100
nchnls=2

giFluidEngine           fluid_engine

giSF_piano      fluid_load  "sf2/Piano Grand Steinway V1.0b (29,651KB).SF2", giFluidEngine
giSF_mutedViolin     fluid_load  "sf2/MutedViolin.sf2", giFluidEngine

fluid_program_select    giFluidEngine, 0, giSF_piano, 0, 0
fluid_program_select    giFluidEngine, 1, giSF_mutedViolin, 0, 0

        instr 1 ;untitled

    fluid_play  giFluidEngine, 0, p4, p5

        endin

    instr 2

    fluid_play  giFluidEngine, 1, p4, p5

    endin

    instr 10 ; fluid out instrument

aleft, aright   fluid_out   giFluidEngine

    outs aleft * 0dbfs, aright * 0dbfs
    endin

</CsInstruments>

<CsScore>

i1 0 2 60 110
i1 0 2 64 110
i1 0 2 67 110

i2 0 1 72 110
i2 0 1 76 70
i2 0 1 79 80

i10 0 6

e

</CsScore>

</CsoundSynthesizer>

```

### jacko_test

```csound
<CsoundSynthesizer>
<CsLicense>

TEST JACKO OPCODES
Michael Gogins

This csd tests the Jacko opcodes.

There is a segmentation fault at the end of the performance. This does happen
in the Jacko plugin, but it does not affect the performance.

Csound not only writes a soundfile using -o, but also sends realtime audio and
MIDI to other Jack clients using Jack connections.

Before running this piece, in a terminal execute:

zynaddsubfx --input JACK --output JACK --auto-connect --sample-rate 48000 --buffer-size 128


</CsLicense>
<CsOptions>
</CsOptions>
<CsInstruments>
; Sampling rate must be the same as Jack's.
sr=48000
; ksmps must be the same as Jack's frames/period.
ksmps=128
nchnls=2
0dbfs=40000

ga_audio_out init 0

; Initialize the Jack connections.
JackoInit "default", "csound6"
prints "Initial ports and connections:\n"
JackoInfo
JackoAudioInConnect "system:capture_1", "audio_in_left"
JackoAudioInConnect "system:capture_2", "audio_in_right"
JackoAudioOutConnect "audio_out_left", "system:playback_1"
JackoAudioOutConnect "audio_out_right", "system:playback_2"
JackoMidiInConnect "system:midi_capture_1", "midiin"
JackoMidiOutConnect "midiout", "zynaddsubfx:midi_input"
prints "Final ports and connections:\n"
JackoInfo

instr 1
print p1, p2, p3, p4, p5
i_frequency = cpsmidinn(p4)
i_amplitude = ampdb(p5)
print i_frequency, i_amplitude
a_out oscil i_amplitude, i_frequency
ga_audio_out += a_out;
endin

; Sends notes to an external MIDI synthesizer.
instr 801
print p1, p2, p3, p4, p5
JackoNoteOut "midiout", 0, p4, p5
prints "Sent note to midiout.\n"
endin

instr 900
print p1, p2, p3
outs ga_audio_out, ga_audio_out
; Input test is only to see if connection is created.
audio_in_left_ init 0
audio_in_right_ init 0
audio_in_left_ JackoAudioIn "audio_in_left"
audio_in_right_ JackoAudioIn "audio_in_right"
JackoAudioOut "audio_out_left",  ga_audio_out
JackoAudioOut "audio_out_right", ga_audio_out
ga_audio_out = 0
endin

instr 1000
print p1, p2, p3
; Uncomment the following two lines to test if Jacko hangs Csound.
event "e", 0, 0, 0.1
prints "Ending Csound performance with 'e' event\n"
endin

</CsInstruments>
<CsScore>
f      0 60
i1     5  3 63  10
i801  10  3 69 100
i1	  15  3 72  10
i900   0 -1
i1000 20  1
e
</CsScore>

</CsoundSynthesizer>
```

### cladsyn

```csound
<CsoundSynthesizer>
<CsOptions>
--opcode-lib=./libclop1.dylib
</CsOptions>
<CsInstruments>

ksmps = 1
0dbfs = 1


instr 1
ifftsize = 2048
ihopsize = 512
ibins = 1024
idev =  1; /* device number */
asig1 vco2 0.5, 300
fsig = pvsanal(asig1, ifftsize,ihopsize, ifftsize, 1)
asig = cladsyn(fsig,1,1,ibins,idev)
asig = linenr(asig,0.001,0.01,0.01)
   out(asig*0.5)

endin

instr 2
ifftsize = 2048
ihopsize = 512
ibins = 1024
asig1 vco2 0.5, 440
fsig = pvsanal(asig1, ifftsize,ihopsize, ifftsize, 1)
asig = pvsadsyn(fsig,ibins,1)
asig = linenr(asig,0.001,0.01,0.01)
    out(asig*0.5)

endin





</CsInstruments>
<CsScore>
i1 0 60
</CsScore>
</CsoundSynthesizer>


```

### clconv

```csound
<CsoundSynthesizer>
<CsOptions>
--opcode-lib=./libclconv.dylib
</CsOptions>
<CsInstruments>

ksmps = 1
0dbfs = 1

gift ftgen 0, 0, 0, 1, "pianoc2.wav", 0,0,1
;tablew 1, 0, gift

instr 1
ipsize = 512
idev =  1; /* device number */
ain mpulse 1, 7
asig clconv ain, gift, ipsize, idev
  out(asig)

endin


</CsInstruments>
<CsScore>
i1 0 10
</CsScore>
</CsoundSynthesizer>


```

### python0

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac
</CsOptions>
<CsInstruments>

sr=44100
ksmps=128
nchnls=2

pyinit ;Start python interpreter

pyruni "print(44100)"

instr 1
endin


</CsInstruments>
<CsScore>
i 1 0 0.1
</CsScore>
</CsoundSynthesizer>
```

### python1

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac
</CsOptions>
<CsInstruments>

sr=44100
ksmps=128
nchnls=2

pyinit ;Start python interpreter

pyruni {{
a = 2
b = 3
print("a + b = " + str(a+b))
}} ;Execute a python script on the header

instr 1
pyruni {{a = 6
b = 5
print("a + b = " + str(a+b))}}
endin


instr 2
pyruni {{print("a + b = " + str(a+b))}}
endin


</CsInstruments>
<CsScore>

i 1 0 0.1
i 2 1 0.1
</CsScore>
</CsoundSynthesizer>
```

### python2

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac
</CsOptions>
<CsInstruments>

sr=44100
kr=100
nchnls=2

pyinit

pyruni "a = 0"

instr 1
    pyrun "a = a + 1"
endin


instr 2
    pyruni {{print("a = " + str(a))}}
endin


</CsInstruments>
<CsScore>

i 1 0 1    ;Adds to a for 1 second
i 2 1 0.1  ;Prints a
i 1 2 1    ;Adds to a for another second
i 2 3 0.1  ;Prints a

</CsScore>
</CsoundSynthesizer>
```

### python3

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac
</CsOptions>
<CsInstruments>

sr=44100
kr=100
nchnls=2

pyinit

pyruni "a = 0.0"

instr 1
    pyrun "a = a + 1"
endin


instr 2
ival pyevali "a"
prints "a = %i\\n", ival
endin


</CsInstruments>
<CsScore>

i 1 0 1    ;Adds to a for 1 second
i 2 1 0.1  ;Prints a
i 1 2 1    ;Adds to a for another second
i 2 3 0.1  ;Prints a

</CsScore>
</CsoundSynthesizer>
```

### python4

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac
</CsOptions>
<CsInstruments>

sr=44100
kr=100
nchnls=2

pyinit

pyassigni "a", 0

instr 1
    pyrun "a = a + 1"
endin


instr 2
ival pyevali "a"
prints "a = %i\\n", ival
endin


</CsInstruments>
<CsScore>

i 1 0 1    ;Adds to a for 1 second
i 2 1 0.1  ;Prints a
i 1 2 1    ;Adds to a for another second
i 2 3 0.1  ;Prints a

</CsScore>
</CsoundSynthesizer>
```

### python5

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac
</CsOptions>
<CsInstruments>

sr=44100
kr=100
nchnls=2

pyinit

pyruni {{
def average(a,b):
    ave = (a + b)/2
    return ave
}} ;Define function "average"

instr 1
iave   pycall1i "average", p4, p5
prints "a = %i\\n", iave
endin


</CsInstruments>
<CsScore>

i 1 0 1  100  200
i 1 1 1  1000 2000

</CsScore>
</CsoundSynthesizer>
```

### pythonlocal

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac
</CsOptions>
<CsInstruments>

gkprint init 0

instr 1
ivalue init p4
ktrig changed gkprint
if (ktrig == 1) then
  printk 0.5, ivalue
endif
endin

instr 2
gkprint init 1
endin

</CsInstruments>

<CsScore>
;          p4
i 1 0 5   100
i 1 1 5   200
i 1 2 5   300
i 1 3 5   400

i 2 3 1
</CsScore>
</CsoundSynthesizer>

```

### pythonlocal2

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac
</CsOptions>
<CsInstruments>

pyinit

gkprint init 0

instr 1
;assign 4th p-field to local python variable "value"
pylassigni "value", p4
ktrig changed gkprint

; If gkprint has changed (i.e. instr 2 was triggered)
; print the value of the local python variable "value"
if (ktrig == 1) then
  kvalue pyleval "value"
  printk 0.5, kvalue
endif
endin

instr 2
gkprint init 1
endin

</CsInstruments>

<CsScore>
;          p4
i 1 0 5   100
i 1 1 5   200
i 1 2 5   300
i 1 3 5   400

i 2 3 1
</CsScore>
</CsoundSynthesizer>

```

### pythonmarkov

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac
</CsOptions>
<CsInstruments>

sr=44100
ksmps=128
nchnls=2

pyinit

; Python script to define probabilities for each note as lists within a list
; Definition of the get_new_note function which randomly generates a new
; note based on the probabilities of each note occuring.
; Each note list must total 1, or there will be problems!

pyruni {{c = [0.1, 0.2, 0.05, 0.4, 0.25]
d = [0.4, 0.1, 0.1, 0.2, 0.2]
e = [0.2, 0.35, 0.05, 0.4, 0]
g = [0.7, 0.1, 0.2, 0, 0]
a = [0.1, 0.2, 0.05, 0.4, 0.25]

markov = [c, d, e, g, a]

import random

random.seed()

def get_new_note(previous_note):
    number = random.random()
    accum = 0
    i = 0
    while accum < number:
        accum = accum + markov[int(previous_note)][int(i)]
        i = i + 1
    return i - 1.0

}}



instr 1  ;Markov chain reader and note spawner
;p4 = frequency of note generation
;p5 = octave
ioct init p5
klastnote init 0 ;Used to remember last note played (start at first note of scale)
ktrig metro p4 ;generate a trigger with frequency p4
knewnote pycall1t ktrig, "get_new_note", klastnote ;get new note from chain
schedkwhen ktrig, 0, 10, 2, 0, 0.2, knewnote, ioct ;launch note on instrument 2
klastnote = knewnote ;New note is now the old note
endin


instr 2 ;A simple sine wave instrument
;p4 = note to be played
;p5 = octave
ioct init p5
ipclass table p4, 2
ipclass = ioct + (ipclass / 100) ; Pitch class of the note
ifreq = cpspch(ipclass) ;Note frequency in Hertz
aenv linen 6000, 0.05, p3, 0.1 ;Amplitude envelope
aout oscil  aenv, ifreq , 1 ;Simple oscillator
outs aout, aout
endin


</CsInstruments>
<CsScore>

f 1 0 2048 10 1 ;sine wave
f 2 0 8  -2  0  2  4  7 9  ;Pitch classes for pentatonic scale

;        frequency of       Octave of
;        note generation    melody
i 1 0 30      3               7
i 1 5 25      6               9
i 1 10 20     7.5             10
i 1 15 15     1               8

</CsScore>
</CsoundSynthesizer>
```

### embeddedCtcsound

```csound
<CsoundSynthesizer>
<CsOptions>
  -odac
</CsOptions>
<CsInstruments>

sr     = 48000
ksmps  = 100
nchnls = 2

pyinit ;Start python interpreter

pyruni {{
import ctcsound
import sys

# Get an opaque pointer to the running Csound instance
# and print Python version number
p = _CSOUND_
print("\\n  --> Python version number: {}\\n".format(sys.version_info[0]))
# Create an object called cs from the ctcsound.Csound class
# using the opaque pointer to the Csound instance
cs = ctcsound.Csound(pointer_=p)
}}

instr 1
  ; Use the cs python object
  pyruni {{
print("\\n  --> Sample Rate: {}, Control Rate: {}\\n".format(cs.sr(), cs.kr()))
  }}
endin

</CsInstruments>
<CsScore>
i1 0 1
</CsScore>
</CsoundSynthesizer>


```

### ievent

```csound
sr=44100
kr=4410
ksmps=10
nchnls=2

giSinusoid      ftgen           0,      0, 8192, 10,    1

pyinit

pyruni  {{
import ctcsound
import sys
from random import random
p = _CSOUND_
print("\\n  --> Python version number: {}\\n".format(sys.version_info[0]))
cs = ctcsound.Csound(pointer_=p)
for i in range(800):
        cs.scoreEvent('i', [1, i * .2,     0.05, 6.8 + random() * 3,   70.0])
        cs.scoreEvent('i', [1, i * .2,     0.05, 8.8 + random() * 3,   70.0])
}}

instr 1

        iDuration       =       p3
        iFrequency      =       cpsoct(p4)
        iAmplitude      =       ampdb(p5)

        aAmplitude      linseg  iAmplitude, iDuration - 0.01, iAmplitude, 0.002 ,0, 1,0
        aOutput         oscili  aAmplitude, iFrequency, giSinusoid

                        outs    aOutput, aOutput

endin

```

### ievent

```csound
f0 60

```

### pyassign

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

pyinit

instr 1

        k1      rand            1000
                pyassign        "a", k1
                pyrun           "print(a)"
endin

```

### pyassign

```csound
i1 0 0.01

```

### pycall1

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

giSinusoid      ftgen   0,      0, 8192, 10,    1

pyinit

pyruni {{
import random

pool = [(1 + i/10.0) ** 1.2 for i in range(100)]

def get_number_from_pool(n, p):
    if random.random() < p:
        i = int(random.random() * len(pool))
        pool[i] = n

    return random.choice(pool)
}}

instr 1

        k1      oscil   1, 3, giSinusoid

        k2      pycall1 "get_number_from_pool", k1 + 2, p4

                printk  0.01, k2

endin

```

### pycall1

```csound
i1 0 10 0.01

```

### pycall2

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

giSinusoid      ftgen   0,      0, 8192, 10,    1

pyinit

pyruni {{
import random

class GetNumberFromPool:
    def __init__(self, e=1.2, a=1.0, f=0.1, N=100):
        self.pool = [(a + i*f) ** e for i in range(N)]

    def __call__(self, n, p):
        if random.random() < p:
            i = int(random.random() * len(self.pool))
            self.pool[i] = n

        return random.choice(self.pool)

get_number_from_pool = GetNumberFromPool()
}}

instr 1

        k1      oscil   1, 3, giSinusoid

        k2      pycall1 "get_number_from_pool", k1 + 2, p4

                printk  0.01, k2

endin

```

### pycall2

```csound
i1 0 10 0.01

```

### pycall3

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

pyinit

pyruni  {{
def f0(a, b, c, d, e, f, g, h):
    pass

def f1(a, b, c, d, e, f, g, h):
    return a

def f2(a, b, c, d, e, f, g, h):
    return a, b

def f3(a, b, c, d, e, f, g, h):
    return a, b, c

def f4(a, b, c, d, e, f, g, h):
    return a, b, c, d

def f5(a, b, c, d, e, f, g, h):
    return a, b, c, d, e

def f6(a, b, c, d, e, f, g, h):
    return a, b, c, d, e, f

def f7(a, b, c, d, e, f, g, h):
    return a, b, c, d, e, f, g

def f8(a, b, c, d, e, f, g, h):
    return a, b, c, d, e, f, g, h
}}

instr 1

                                 pycall  "f0", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1                             pycall1 "f1", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2                         pycall2 "f2", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3                     pycall3 "f3", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4                 pycall4 "f4", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4, k5             pycall5 "f5", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4, k5, k6         pycall6 "f6", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4, k5, k6, k7     pycall7 "f7", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4, k5, k6, k7, k8 pycall8 "f8", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8

        printk  0.01, k1
        printk  0.01, k2
        printk  0.01, k3
        printk  0.01, k4
        printk  0.01, k5
        printk  0.01, k6
        printk  0.01, k7
        printk  0.01, k8
endin

```

### pycall3

```csound
i1 0 0.1

```

### pycallt

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

pyinit

pyruni  {{
def f0(a, b, c, d, e, f, g, h):
    print('f0 got', a, b, c, d, e, f, g, h)
    print('f0 returning None')

def f1(a, b, c, d, e, f, g, h):
    print('f1 got', a, b, c, d, e, f, g, h)
    print('f1 returning', a)
    return a

def f2(a, b, c, d, e, f, g, h):
    print('f2 got', a, b, c, d, e, f, g, h)
    print('f2 returning', a, b)
    return a, b

def f3(a, b, c, d, e, f, g, h):
    print('f3 got', a, b, c, d, e, f, g, h)
    print('f3 returning', a, b, c)
    return a, b, c

def f4(a, b, c, d, e, f, g, h):
    print('f4 got', a, b, c, d, e, f, g, h)
    print('f4 returning', a, b, c, d)
    return a, b, c, d

def f5(a, b, c, d, e, f, g, h):
    print('f5 got', a, b, c, d, e, f, g, h)
    print('f5 returning', a, b, c, d, e)
    return a, b, c, d, e

def f6(a, b, c, d, e, f, g, h):
    print('f6 got', a, b, c, d, e, f, g, h)
    print('f6 returning', a, b, c, d, e, f)
    return a, b, c, d, e, f

def f7(a, b, c, d, e, f, g, h):
    print('f7 got', a, b, c, d, e, f, g, h)
    print('f7 returning', a, b, c, d, e, f, g)
    return a, b, c, d, e, f, g

def f8(a, b, c, d, e, f, g, h):
    print('f8 got', a, b, c, d, e, f, g, h)
    print('f8 returning', a, b, c, d, e, f, g, h)
    return a, b, c, d, e, f, g, h
}}

instr 1

        kt      metro   1.5

                                 pycallt  kt, "f0", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1                             pycall1t kt, "f1", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2                         pycall2t kt, "f2", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3                     pycall3t kt, "f3", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4                 pycall4t kt, "f4", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4, k5             pycall5t kt, "f5", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4, k5, k6         pycall6t kt, "f6", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4, k5, k6, k7     pycall7t kt, "f7", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
  k1, k2, k3, k4, k5, k6, k7, k8 pycall8t kt, "f8", 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8
endin

```

### pycallt

```csound
i1 0 10

```

### pyeval

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

        pyinit

        pyruni  "from random import random"

instr 1

                pyrun   "a = random()"
        k1      pyeval  "a"
                printk  0.1, k1
endin

```

### pyeval

```csound
i1 0 0.5

```

### pyexec

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

        pyinit

        pyruni "import random"

        pyexeci "pyexec1.py"

instr 1

        pyexec          "pyexec2.py"

        pylexeci        "pyexec3.py"
        pylexec         "pyexec4.py"

endin

```

### pyexec

```csound
i1 0 0.01
i1 0 0.01

```

### pyexect

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

pyinit

instr 1

        ktrigger1       metro           3
        ktrigger2       metro           6
        ktrigger3       metro           10
        ktrigger4       metro           0.5

        pyexect         ktrigger1, "pyexect1.py"
        pyexect         ktrigger2, "pyexect2.py"
        pyexect         ktrigger3, "pyexect3.py"

        pylexect        ktrigger3 + ktrigger1, "pyexect4.py"

        a1              rand            5000

                        out             a1

endin

```

### pyexect

```csound
i1 0 5
i1 0 5

```

### pyrun

```csound
<CsoundSynthesizer>
<CsOptions>
 -odac
</CsOptions>
<CsInstruments>
sr=44100
kr=4410
ksmps=10
nchnls=1

pyinit

pyruni "import random"

instr 1
        ; This message is stored in the main namespace
        ; and is the same for every instance
        pyruni  "message = 'a global random number: %f' % random.random()"
        pyrun   "print(message)"

        ; This message is stored in the private namespace
        ; and is different for different instances
        pylruni "message = 'a private random number: %f' % random.random()"
        pylrun  "print(message)"

endin
</CsInstruments>
<CsScore>
i1 0 0.01
</CsScore>
</CsoundSynthesizer>

```

### pyrun

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

pyinit

pyruni "import random"

instr 1
        ; This message is stored in the main namespace
        ; and is the same for every instance
        pyruni  "message = 'a global random number: %f' % random.random()"
        pyrun   "print(message)"

        ; This message is stored in the private namespace
        ; and is different for different instances
        pylruni "message = 'a private random number: %f' % random.random()"
        pylrun  "print(message)"
endin

```

### pyrun

```csound
i1 0 0.1

```

### pyrunt

```csound
sr=44100
kr=4410
ksmps=10
nchnls=1

pyinit

instr 1

        ktrigger1       metro           3
        ktrigger2       metro           6
        ktrigger3       metro           10

        pyrunt          ktrigger1, "print('zum')"
        pyrunt          ktrigger2, "print('pa')"
        pyrunt          ktrigger3, "print('zi')"

        pylrunt         ktrigger3 + ktrigger1, "print('zut')"

        a1              rand            5000

                        out             a1
endin

```

### pyrunt

```csound
i1 0 5
i1 0 5

```

## Full Documentation

Plugins for Csound 6.x
=======

Currently, the plugins available in this tree are

- AbletonLive Link (requires Ableton link)
 **link_create link_enable link_is_enabled link_tempo_set link_tempo_get link_beat_get link_metro link_beat_request link_beat_force**

- chua (requires Eigen library, header-only)
 **chuap**

- Faust (requires libfaust)
 **faustgen faustcompile faustaudio faustdsp faustplay faustctl**

- image (requires libpng)
 **imageload imagesave imagecreate imagesize imagegetpixel imagesetpixel imagefree**

- py (requires a Python 3.x installation with dev libs)
 **Many opcodes to call Python code**

- widgets (requires the FLTK LIB)
**FLTK-based widgets.**
NB: These opcodes do not work correctly on MacOS due
to incompatibilities with the operating system.

- virtual keyboard (requires the FLTK LIB)
**Virtual MIDI keyboard midi backend**

- STK opcodes (requires STK library)
**Physical model opcodes using the STK library**


Install location
--------------
The CMake scripts in this repository use the default CS_USER_PLUGIN
location on MacOS and Windows as defined in the Csound build, or a
library instalation directory (customisable) on LINUX. These are:

- LINUX: depends on both `CMAKE_INSTALL_PREFIX` and `USE_LIB64`. It is then installed in:
   * if `USE_LIB64=1` then to
       * for doubles: `${CSOUND_INSTALL_PREFIX}/lib64/csound/plugins64-${APIVERSION}`
       * for floats: `${CSOUND_INSTALL_PREFIX}/lib64/csound/plugins-${APIVERSION}` (floats)`
   * if `USE_LIB64=0` then to
       * for doubles: `${CSOUND_INSTALL_PREFIX}/lib/csound/plugins64-${APIVERSION}`
       * for floats: `${CSOUND_INSTALL_PREFIX}/lib/csound/plugins-${APIVERSION}`

- MACOS:
    * For doubles: `$HOME/Library/csound/${APIVERSION}/plugins64`
    * For floats: `$HOME/Library/csound/${APIVERSION}/plugins`
- Windows:
    * For doubles: `%LOCALAPPDATA%\csound\${APIVERSION}\plugins64`
    * For floats: `%LOCALAPPDATA%\csound\${APIVERSION}\plugins`


Build Instructions for Linux and MacOS
---

The build requires Csound to be installed, as well as CMake. With this
in place, you can do :

```
$ git clone https://github.com/csound/plugins.git
$ cd plugins
$ mkdir build
$ cd build
$ cmake ../
$ make
```

By default, all the plugins are built. If one wants to exclude a
plugin from the build process, one can pass an option to the cmake command.
For example, to exclude the chua plugin, the `cmake` command would be:

```
$ cmake -DBUILD_CHUA_OPCODES=OFF ../
```

For the FLTK dependent plugins, the configuration variable used is
`USE_FLTK`.

To install the opcodes you have built

```
$ make install
```

Depending on your permissions, you might need to prepend `sudo` to
these commands. After the first build the plugins can be updated with

```
$ git pull
$ make
$ make install
```

using `sudo` in the last step if raised permissions are needed. On
Linux, the installation location can be set with the relevant CMake
variables as indicated above.

Csound Location
------------
CMake will normally find the installed Csound headers (and library)
automatically. However, if your Csound headers and library are not
placed in the usual locations, you can use the following CMake option variables
to tell CMake where they are:

```
CSOUND_INCLUDE_DIR_HINT
```
and

```
CSOUND_LIBRARY_DIR_HINT
```
