---
source: Csound Journal
issue: 20
title: "PWCsound"
author: "several historical libraries for Patchwork"
url: https://csoundjournal.com/issue20/PWCsound.html
---

# PWCsound

**Author:** several historical libraries for Patchwork
**Issue:** 20
**Source:** [Csound Journal](https://csoundjournal.com/issue20/PWCsound.html)

---

CSOUND JOURNAL[](https://csoundjournal.com/../index.html) | [Issue 20](https://csoundjournal.com/index.html)
## PWCsound

### A Visual Composition Tool for the Csound Language
 Giorgio Zucco
 giorgiozucco AT teletu.it
## Introduction


One of the most fascinating and relatively recent areas related to the world of electro-acoustic music—even chamber music, symphonic and opera as well—is computer-aided composition. It is a visual programming environment (similar to languages such as Max/MSP, Pure Data, Kyma) in which the composer creates algorithms to formalize, analyze, and process musical materials, whether melodic, rhythmic, or harmonic. The advantage of these systems is their ability to work to a high-level of sonic representation through practical editors employing staves.

PWCsound is, of course, inspired by several historical libraries for Patchwork (in particular from Csound/Edit-sco for Patchwork, better known as PW-Csound, 1993)[[1]](https://csoundjournal.com/#ref1) and Open Music. The connection between the techniques of computer aided composition and sound synthesis has been explored within these softwares:
- Csound/Edit-sco (by Laurent Pottier, Mikhael Matl, 1993, this work is the first historical version of PWCsound)[[1]](https://csoundjournal.com/#ref1)

- Pwcollider (by Michael Laurson, 1999 )[[2]](https://csoundjournal.com/#ref2)

- Om2Csound (by Karim Haddad, Mikhail Malt, Laurent Pottier, Jean Bresson, 1999)[[3]](https://csoundjournal.com/#ref3)

- OmChroma (Jean Bresson, Carlos Agon, Marco Stroppa, Serge Lemouton, 1998)[[4]](https://csoundjournal.com/#ref4)

PWCsound builds upon these softwares and offers an upgraded system to use the latest Csound release, as well as integration into PWGL. PWCsound would never have been created without the previous work of such extraordinary musicians and programmers.

The ultimate release of Csound6 has been decisive. The developers have introduced a new type of syntax based on the concept of functions, maintaining compatibility with the historical language of Csound.

At the time of this writing, PWCsound works best in OSX. This does not exclude its use in a Windows environment, however, execution in realtime and rendering to disk within PWGL is possible only in the OSX version. In order to work on Windows, you can run a .csd file created from the library outside the program, such as with Winxound or CsoundQt. A full PWCsound windows version is under development.
##  I. Download and Installation


The following is the link to download PWCsound: [http://pwcsound.jimdo.com/download/](http://pwcsound.jimdo.com/download/)

Listed below are the basic requirements for PWCsound on MacOSX:
- PWGL - Rc 17 or higher

- OSX 10.6 or higher

- Csound 6.00 or higher (the .csd files generated by PWCsound are not compatible with previous Csound versions)
### Installation Instructions

- In the Macintosh HD directory, copy the folder named "pwcs". This folder contains numerous UDOs, tables, samples, and other items.

- Copy the file folder named "PWCsound" to the path: /Applications/PWGL/pwgl-library.

On the OSX Mavericks system, it is important to set the privileges to"reading and writing" for these folders, as PWCsound will write .csd files to the Macintosh HD directory. You can specify other directories to use for writing, but we suggest this way to simplify the first steps, in order to be able to use the rich set of tutorials available with the download. In Figure 1, shown below, is a basic view of PWCsound.

![1](images/Zucco/1.png) **Figure 1. A basic view of PWCsound.**

After you have installed the PWCsound library, open PWGL and from the file menu select "Autoload libraries" or "Load library". This will enable PWCsound for use within PWGL.

At first glance from the numerous menus, one feels a kind of familiarity with *The* *Csound Cannonical Reference Manual* [[5]](https://csoundjournal.com/#ref5)format; however, we can see many new object names in comparison with the many opcodes in the synthesis language. These are User Defined Opocodes that can be used in all areas of Csound, such as writing processes, synthesis, mathematical operations, triggering and so on.

The user can work on two levels: on one side it is possible to perform low-level traditional programming, and on the other side a high level approach is possible. An example of a high-level approach is the `simple-scan` (scanned synthesis based) object. This object is a complex systems synthesis and signal processing object translated into a simple object with a few essential parameters. Thse main parameters are identical to a simple oscillator comparable to the `oscil` opcode.

 At present, only the main Csound opcodes have been introduced. This was a decision dictated by technical considerations as well as aesthetic choice. Specific opcodes for spatialization, vector processing, linear algebra, and FLTK, as well as he Loris family of opcodes, were left out of this release.

![2](images/Zucco/2.png)**Figure 2. Help Documentation.**

Shown above in Figure 2, is the Help Documentation. Every object has a brief help associated with it. In order to access it, select the object, right click and choose "documentation". Notice how the object name is different than the traditional Csound opcode name, e.g., the `timestretch` object is based on the `temposcal` opcode, etc.
## II. PWCsound Tutorials


![3](images/Zucco/3.png)**Figure 3. PWCsound library tutorials.**

The library tutorials can be accessed easily from the Help Menu, shown in Figure 3, and this introduces the first tutorial. From the "Basic" folder, open the file "test", shown below in Figure 4.

![4](images/Zucco/4.png)**Figure 4. PWCsound library tutorials. The first tutorial, "test".**

This simple example shows some of the most important PWCsound objects for performing tasks such as rendering in realtime and to disk, utilizing `make.csd.`

`Sketch` is a form used to easily and effectively test and prove the synthesis tools. The object makes a .csd file (mono output) with full header and provides the basic parameters of the Csound score (p2, p3, p4, p5). The parameter p5 will receive data (only one note at a time) in MIDI format, and will convert MIDI to frequency (m to f).

`Pluck` is the historical Csound opcode, here simplified with the essential input parameters (default parameters such as `iparm`, etc., are not considered in this module). It is possible to connect any type of modulation to the two inputs, `ampdev` or `freqdev`.

`Open-csd`, is not part of the object library, but is a convenient subpatch (in PWGL they are called abstractions) which is able to view the .csd file already created. It opens a Csound editor (such as Winxound or CsoundQt).

`Synthesize` is a module which writes a .csd file in the specified directory. By default it writes the file to the Macintosh HD. Select the object and press the "V" key to start realtime rendering (flag: `-odac`). Shown below is the source of the file created after you run the `Synthesize object`.
```csound

<CsoundSynthesizer>
<CsOptions>
</CsOptions>
<CsInstruments>
sr=44100
kr=44100
ksmps=1
nchnls = 1
0dbfs=1

#include "pwcs\pwcsound.inc"

instr 1
asig = pluck( p4 , p5 , 440 , 0 , 1 )
out asig
endin

</CsInstruments>
<CsScore>
i1   0   2   0.5   261.62555
</CsScore>
</CsoundSynthesizer>

```


Starting from this simple example, we can work with the new Csound 6 function-call syntax, to which the full library is dedicated. The p5 parameter of the score, is directly converted into frequency from MIDI data (the input values coming from the Chord-Editor's MIDI value).

The next step is to become familiar with this new visual programming tool. Try to add an amplitude envelope, a vibrato, or connect the `pluck` output to a filter, or a resonator. How can we add a simple low frequency oscillator? Use the `add` object ("+" operator) and an opcode like `lfo`, `vibr` or `vibrato`, and connect it to the `add` object. The `add` output will be connected to the `freq-dev` input of `pluck`.

While working with the realtime compilation processes, the Csound engine may be called internally inside PWGL. One can view the Csound output by using the function `Output Browser `(in OSX, press cmd+B), shown in Figure 5.

![5](images/Zucco/5.png)**Figure 5. Csound output using the Output Browser.**
### A More Complex Patch


The next tutorial shows an example of algorithmic composition in order to generate a melody. Open the "score-melody-2.pwgl " patch from help tutorials, shown in Figure 6.

![6](images/Zucco/6.png)**Figure 6. Open the patch "score-melody-2.pwgl".**

 This patch opens two new object so as to describe the orchestra and score in a more comprehensive and extensible way.

The `orc-sco` object allows setting the header of our Csound instrument. The two inputs refer to a separate orchestra and score. The `multi-score` object allows writing a score with a number of user-defined parameters. By default, it is set up with five main parameters in order to add other p-fields. Open the "object properties" and select `add-output`.

 To generate data for attack and duration, the patch uses the PWGL `g-random` object to define value ranges. The editor contains chords within one harmonic spectrum generated previously according to the historic library called Esquisse—originally created by Tristan Murail for PatchWork, and is included with PWGL—which provides a harmonic series generated by a known, defined pitch base.

The pitch list will also determine the number of events in the score. The list length is obtained by the Lisp function "length", and the result of this operation will connect to the object `pwgl-repeat`. (See later how this can be done automatically using the object `p2-seq`).

Start the `synthesize` object for realtime processing. Below is the score generated from the .csd file.
```csound

i 1   6.9851613   1.1713662   0.5   46.24931
i 1   3.1818576   1.6515608   0.5   92.498604
i 1   1.4789168   1.3654573   0.5   138.7479
i 1   2.6020398   0.44820833   0.5   184.99721
i 1   4.7233033   0.748575   0.5   231.24652
i 1   6.342833   0.8193362   0.5   277.49582
i 1   7.6177   1.3719283   0.5   323.74512
i 1   3.4181419   0.71874154   0.5   369.99442
i 1   0.14782676   1.0883918   0.5   416.24374
i 1   7.667928   0.67370207   0.5   462.49304
i 1   4.4143815   2.0354374   0.5   508.74225
i 1   7.116709   0.81711746   0.5   554.9916
i 1   5.38734   0.8157411   0.5   601.2408
i 1   4.96901   1.3378495   0.5   647.4901
i 1   0.51617587   0.5245011   0.5   693.7393
i 1   5.138469   1.9867685   0.5   739.98884
i 1   4.9790216   2.191455   0.5   786.23804
i 1   1.6194817   1.9501834   0.5   832.4875
i 1   3.8366542   1.1336662   0.5   878.73664
i 1   2.5282827   0.4624824   0.5   924.9861
i 1   1.5269009   1.1401311   0.5   971.23536
i 1   3.4141097   0.7665303   0.5   1017.4845
i 1   4.4922614   1.5228187   0.5   1063.7341
i 1   4.4985967   0.8579705   0.5   1109.9832
i 1   7.285685   0.563047   0.5   1156.2324
i 1   1.5275704   1.9574592   0.5   1202.4816
i 1   4.223684   1.641706   0.5   1248.7316
i 1   6.0374675   0.46914607   0.5   1294.9801
i 1   3.1438804   1.9934442   0.5   1341.2296
i 1   0.3686224   0.4062045   0.5   1387.4788
i 1   5.86278   0.9945724   0.5   1433.7284
i 1   5.0010047   1.0696277   0.5   1479.9777
i 1   1.6323067   1.5650109   0.5   1526.227

```
 [![](images/zucco/ex1mp3.png)](https://csoundjournal.com/audio/zucco_melody.mp3)** **Audio Example1, melody.mp3. **

These are only a few basic examples of the potential offered by this system. There is no limit to the creative possibilities of using various orchestras and multiple scores together within the same patch.
### Additive Synthesis


The above example gives a very suitable method for the generation of an oscillator-bank. The following example is loosely inspired by a patch from the OMChroma[[4]](https://csoundjournal.com/#ref4) library available in Open Music.

![7](images/Zucco/7.png)**Figure 7. Patch "harmonic-series-2.pwgl".**

Open the file "harmonic-series-2.pwgl" from the Additive folder, shown in Figure 7. In this patch twenty-five partials, based on chord-editor list, are generated.

The single sine wave oscillator has a frequency modulated by an LFO with variable rate (parameter `p6` of the score). Try editing the partial-chord editor with another harmonic-series. You can increase the complexity of the individual oscillator either by generating numerical series for the amplitude parameters, or specifying an envelope with variable data for each instance of the score.

This patch uses the p2-seq object to generate the attack data, it is a variant of PWGL "arithm-ser" object which defines an increasing numerical list. In this example we have a 0.1 value increase between an instance of attack and the consequent.

The object takes as input p2-seq data from chord-editor—though it can accept data from any list type—from which it extracts the list length (output 2). This output data will be crucial to define the instance numbers in the score.

The generated .csd file is shown below.
```csound

<CsoundSynthesizer>
<CsOptions>
</CsOptions>
<CsInstruments>
sr= 44100
ksmps=1
nchnls=1
0dbfs=1

#include "pwcs\pwcsound.inc"

instr 1
asig = poscil( p4 , p5 + lfo:k( 6 , p6 , 1 ) , gisine )
out asig
endin

</CsInstruments>
<CsScore>

i 1   0   4   0.1   65.40639   3.5830505
i 1   0.1   4   0.1   130.81278   10.594173
i 1   0.2   4   0.1   196.21916   9.725747
i 1   0.3   4   0.1   261.62555   0.71524197
i 1   0.4   4   0.1   327.03195   5.4496446
i 1   0.5   4   0.1   392.43826   5.566373
i 1   0.6   4   0.1   457.8446   3.5571087
i 1   0.70000005  4   0.1   523.2511   6.8312965
i 1   0.8000001   4   0.1   588.65754   10.113609
i 1   0.9000001   4   0.1   654.0639   10.742955
i 1   1.0000001   4   0.1   719.47016   5.663019
i 1   1.1000002   4   0.1   784.8765   7.016704
i 1   1.2000002   4   0.1   850.28296   7.861312
i 1   1.3000002   4   0.1   915.6892   11.551269
i 1   1.4000002   4   0.1   981.09607   3.3865908
i 1   1.5000002   4   0.1   1046.5022   9.737631
i 1   1.6000003   4   0.1   1111.9086   4.345859
i 1   1.7000003   4   0.1   1177.3146   5.8744207
i 1   1.8000003   4   0.1   1242.7213   1.5213988
i 1   1.9000003   4   0.1   1308.1278   10.08806
i 1   2.0000003   4   0.1   1373.5342   5.1126347
i 1   2.1000002   4   0.1   1438.9403   11.757683
i 1   2.2   4   0.1   1504.3472   1.969416
i 1   2.3   4   0.1   1569.7532   7.5208054
i 1   2.3999999   4   0.1   1635.1597   9.092624

</CsScore>
</CsoundSynthesizer>

```
 [![](images/zucco/ex2mp3.png)](https://csoundjournal.com/audio/zucco_additive.mp3) **Audio Example2, additive.mp3.**
### Overview of Synthesis Opcodes


![8](images/Zucco/8.png) **Figure 8. Synthesis techniques in PWCsound.**

PWCsound uses a number of opcodes in order to create infinites of synthesis techniques as shown in Figure 8. Many opcodes are still missing and will be introduced with further developments. In addition to the historical opcodes (`oscil`, `pluck`, `buzz`, etc.) another group of UDO-based opcode objects are also introduced. The intricacy of some modules i.e. the high number of input parameters, is due to the complexity of the synthesis method. Let us take a brief look at some of the synthesis modules currently implemented in the patch.

When opened, each module is configured with default data. Some opcodes may not have access to certain optional parameters available directly within Csound. In many cases, those parameters are used internally by the library.

An example is the `pluck` opcode: the `iparm` parameter is able to define the plucked string timbres, ranging up to percussive sounds like a snare drum. In PWCsound, one can find a specific object called `pluck` based on the settings of the `pluck` opcode to create this plucked string sound. For a more complete version there is the `pluck2` object as well. It is the full Csound opcode with optional parameters.

The modules that require data from a table such as `poscil`, `buzz`, and `diskgrain`, can be used in tandem with some objects based on the `ftgenonce` opcode (a function table within an instrument definition). These objects can be found in the "Tools" menu of the library (`GEN10`, `menu-grain`, `menu-gen`, etc.).
### Conversion of Harmonic and Melodic Structures to a Csound Score


This patch will illustrate one of the many ways in which chords, harmonic structures or entire harmonic progressions can be converted into a Csound score via any method of sound synthesis. We have already met the `Chord-editor` object in the previous patch, a tool of PWGL able to define any type of melodic structures or harmonics by means of a double staff line.

From the Basic folder of our tutorial, open the patch "score-progression.pwgl".

![9](images/Zucco/9.png)**Figure 9. Patch "score-progression.pwgl".**

The patch shown in Figure 9 is a traditional II - V - I progression in the key of C, a typical jazz harmony. The append method connects the MIDI data of these three chords by means of some abstractions (Chord-A, Chord-B,etc). Inside this abstraction there is a series of modules generating the score fragment of that particular arrangement, through the `multi-score` object.

The generated score:
```csound

i 1   0   2   0.2   174.61412
i 1   0   2   0.2   261.62555
i 1   0   2   0.2   440.0
i 1   0   2   0.2   659.2551
i 1   2   2   0.2   174.61412
i 1   2   2   0.2   246.94165
i 1   2   2   0.2   415.3047
i 1   2   2   0.2   622.25397
i 1   4   4   0.2   164.81378
i 1   4   4   0.2   246.94165
i 1   4   4   0.2   391.99542
i 1   4   4   0.2   587.3295

```


Below, in Figure 10, is an example of monody that demonstrates a prototype of a bridge between the `score-editor` object and PWCsound library. Unlike the `chord-editor` used in previous patches, this use of `score-editor` allows for the display and editing of musical data both in mensural and non-mensural form (where you can also integrate multiple instances of various staves, just like an orchestral score).

From the compositional point of view it becomes very interesting to generate the traditional parameters of sound such as attack, duration, and pitch, starting from musical material using traditional notation. Imagine a complex algorithmic patch whose output is a melodic sequence on the staff. In the current version of the patch, the transfer of musical data from the `score-editor` to Csound score format provides remarkable results with monophonic structures. The use of polyphonic scores is a development for a future library release.

![10](images/Zucco/10.png)**Figure 10. Patch "pwgl-score-editor2.pwgl" showing traditional musical notation.** [![](images/zucco/ex3mp3.png)](https://csoundjournal.com/audio/zucco_score-editor.mp3) **Audio Example3, score-editor.mp3.**

The abstraction of attack and durations, shown in Figure 11, is carried out by an analysis of the melodic material from the `score-editor` by means of objects from the KSQuant library (available online [here](http://sprotte.org/lisp/#ksquant)), the module `score-editor` also offers the ability to import and display a MIDI file.

![11](images/Zucco/11.png)**Figure11. Resulting music notation of melodic attack and duration anaylsis.**
### Real Time Performance


As we can see, the PWCsound library exists mainly for the purpose of building a bridge between the techniques of assisted composition and the control of sound synthesis. Developments in Csound in the last decade go hand in hand with the growing computing power of current CPUs. This has built a powerful system for realtime processing in all its aspects e.g. the construction of MIDI synthesizers, live electronics techniques, the processing of external audio signals and much more. In the current library version of PWCsound, some tools (in a very experimental version at the moment) were introduced in order to describe, build and run live performances.

Let us see an example of how to build a MIDI synthesizer played in realtime using an external MIDI controller. In the demonstration patch, we will use the Csound Virtual MIDI keyboard to trigger events. The `fout` opcode will be activated in order to render-to-disk the live performance.

![12](images/Zucco/12.png)**Figure 12. A patch to build a midi synthesizer.**

The patch instrument shown in Figure 12 consists of a synthesizer in a doubled structure. It is a model of plucked string combined with a phase modulation synthesizer. The two outputs are separated into left and right signals. Both synthesis methods share the same LFO and amplitude envelope. A second instrument is always active for the reverb (`reverbsc`), and a third instrument provides increasingly active feedback delay in a 70s style tape delay.

The three instruments are contained in three respective abstractions. Let us look at the contents of the synth abstractions shown below in Figure 13.

![13](images/Zucco/13.png)**Figure 13. Midisynth abstractions.**

The synthesizer signal is sent to the DSP processing modules (reverb and delay) using the `vincr` opcode. The `gainslider `object checks and balances the right signal output levels. The patch enables the Virtual MIDI keyboard for the duration of the performance shown (in this case twenty seconds). In Audio Example 4, below, one can listen to a recording of a performance.

In the current Csound 6 release, the new function-call syntax does not provide for the use of modules with two audio outputs (such as `reverbsc`, `vbap`), therefore, it was necessary to rewrite these opcodes as a UDO with a single output. Of course, with future developments of the library it will certainly be possible to integrate the full capabilities of a specific opcode in PWCsound.

Let us view the . csd file of realtime MIDI synth, shown below.
```csound

<CsoundSynthesizer>
<CsOptions>
-odac -+rtmidi=virtual -M0
</CsOptions>
<CsInstruments>
sr=44100
ksmps=1
nchnls=2
0dbfs=1

#include "pwcs\pwcsound.inc"

garev   init   0
gadelay   init   0

instr 1

asig1 = pluck( ampmidi(1) * mxadsr:k( 0.05 , 0.5 , 1 , 0.2 ) , cpsmidi() + lfo:k( 4 , 6 , 1 ) , 220 , 0 , 1 , 0 , 0 ) * gainslider( 120 )
asig2 = phasemod( ampmidi(1) * mxadsr:k( 0.05 , 0.5 , 1 , 0.2 ) , 0.5 + lfo:k( 4 , 6 , 1 ) , cpsmidi() , randomi:k( 1 , 5 , 2 , 0 ) , 0.01 ) * gainslider( 100 )

outs asig1 , asig2
vincr( garev , asig1 )
vincr( garev , asig2 )
vincr( gadelay , asig1 )
vincr( gadelay , asig2 )
endin

instr 2

asig1 = revsc( garev , garev , 0.85 , 12000 , 1 ) * gainslider( 100 )
asig2 = revsc( garev , garev , 0.85 , 12000 , 1 ) * gainslider( 100 )
outs asig1 , asig2
clear( garev )

endin

instr 3

asig1 = vintagecho( gadelay , 1 , 1 , 8000 )
asig2 = vintagecho( gadelay , 1 , 1 , 8000 )
outs asig1 , asig2
clear( gadelay )
endin

instr   9999

a1,a2   monitor
fout   "/sound.wav" , 14 ,a1,a2

endin

</CsInstruments>
<CsScore>

i1   0   20
i2   0   20
i3   0   20
i9999 0 20

</CsScore>
</CsoundSynthesizer>

```
 [![](images/zucco/ex4mp3.png)](https://csoundjournal.com/audio/zucco_midisynth.mp3) **Audio Example4, midisynth.mp3.**

In this brief overview we have only dealt with a few of the possibilities of this new approach to Csound programming. On one hand the essence of the library is represented by the fusion of computer aided composition techniques with sound synthesis. On the other hand you can use the system as a visual editor for Csound, in order to build synthesizers such as modular systems, work with digital signal processing, create environments for live electronics, develop sequencers for composition, create a traditional multitrack sequencer, work with multiple orchestras, or, for the more daring, build an entire composition in the form of patches.

For those who want to begin with PWCsound, in addition to basic knowledge of PWGL, it is useful to start with the tutorials (continuously updated in new releases) in the Help section of the program, of which we have already shown a few examples. One of the most interesting fields of exploration might be the development of Lisp classes in abstractions form, in which complex synthesis procedures may be gathered in a single reusable object.
### Acknowledgements


Special thanks to Professor Fabio De Sanctis De Benedictis, for his valuable advice and encouragement in the development of these tutorials about the use of the score editor. Special thanks to my student Michele Vincenzoni, composer Alessandro DiPaola and also to the people from the PWGL forum.
## References


[][1]Laurent Pottier, and Mikhail Malt, "CSound/Edit-sco, Library of Modules for Generating Csound scores - reference manual." Ircam, Paris, 1993.

[][2]Mikael Laurson, "PWCollider - A Visual Composition Tool for Software Synthesis." [Online] Available:[http://quod.lib.umich.edu/cgi/p/pod/dod-idx/pwcollider-a-visual-composition-tool-for-software-synthesis.pdf?c=icmc;idno=bbp2372.1999.328](http://quod.lib.umich.edu/cgi/p/pod/dod-idx/pwcollider-a-visual-composition-tool-for-software-synthesis.pdf?c=icmc;idno=bbp2372.1999.328) . [Accessed September 17, 2014].

[][3]Karim Haddad, Mikhail Malt, Laurent Pottier, and Jean Bresson, "OM2Csound." [Online] Available: [http://support.ircam.fr/docs/om-libraries/main/co/OM2Csound.html.](http://support.ircam.fr/docs/om-libraries/main/co/OM2Csound.html) [Accessed September 16, 2014].

[][4]Carlos Agon, Jean Bresson, Marco Stroppa, "OMChroma: Compositional Control of Sound Synthesis." Computer Music Journal, 35(2), pages 67-83, 2011. [Online] Available: [http://www.mitpressjournals.org/doi/abs/10.1162/COMJ_a_00057#.VBhjRy5dXCw](http://www.mitpressjournals.org/doi/abs/10.1162/COMJ_a_00057#.VBhjRy5dXCw). [Accessed September 16, 2014].

[][5] Barry Vercoe et al., 2005. "Cscore." *The Canonical Csound Reference Manual*. [Online] Available: [http://www.csounds.com/manual/html/](http://www.csounds.com/manual/html/CscoreTop.html). [Accessed September 16, 2014].
### Additional Resources


Mikael Laurson, Mika Kuuskankare, Vesa Norilo, "An Overview of PWGL, a Visual Programming Environment for Music." Computer Music Journal, 33(1), pages 19-31, 2009. [Online] Available: [https://wikis.utexas.edu/download/attachments/4590117/overviewofpwglpdf.pdf](https://wikis.utexas.edu/download/attachments/4590117/overviewofpwglpdf.pdf) . [Accessed September 17, 2014].

Carlos Agon, Marco Stroppa, Gérard Assayag, "High Level Musical Control of Sound Synthesis in OpenMusic." Proceedings of the International Computer Music Conference, Berlin, Germany, 2000. [Online] Available: [http://recherche.ircam.fr/equipes/repmus/RMPapers/icmc2000/index.html](http://recherche.ircam.fr/equipes/repmus/RMPapers/icmc2000/index.html). [Accessed September 16, 2014].

Marco Stroppa, "Paradigms For The High-Level Musical Control Of Digial Signal Processing." Proceedings of the COST G-6 Conference on Digital Audio Effects (DAFX-00), December 7-9, 2000. [Online] Available: [http://profs.sci.univr.it/~dafx/Final-Papers/pdf/Stroppa.pdf](http://profs.sci.univr.it/~dafx/Final-Papers/pdf/Stroppa.pdf) . [Accessed September 16, 2014].

Symbolic Sound Corporation, "Kyma X Revealed." [Online] Available: [http://www.symbolicsound.com/cgi-bin/bin/view/Products/KymaXRevealed](http://www.symbolicsound.com/cgi-bin/bin/view/Products/KymaXRevealed). [Accessed September 16, 2014].
