# 1. The relationship between oscillator frequency f, si, table size l and sampling rate

1. The relationship between oscillator frequency f, si, table size l and sampling rate
sr is:
f = si√ó sr
l
(12.3)
We can use si in eq. 12.3 to control the playback speed, which can be negative
for backwards play. Listing 12.1 shows the code for a simple mono sample playback
instrument using the poscil oscillator. It has parameters for amplitude, playback
speed (faster, kspd > 1; slower, 0 < kspd < 1; backwards, kspd < 0) and function
table.
12.2 Source-ModiÔ¨Åer Methods
217
Listing 12.1 Mono sampler UDO
/**************************************
asig MonoSampler kamp, kspd, ifn
kamp - amplitude
kspd - playback speed
ifn - source function table
****************************************/
opcode MonoSampler,a,kki
kamp,kspd,ifun xin
xout poscil(kamp,kspd*sr/ftlen(ifun),ifun)
endop
This simple method will not allow control over the loop points (the oscillator
will loop over the whole table). More complex instruments can be created with
table-reading opcodes. Alternatively, we can employ a specialised opcode for this.
There are two options for this: looping points can be taken from the soundÔ¨Åle
header (RIFF-Wave and AIFF formats allow for this), or we can set them directly in
Csound. Some soundÔ¨Åle-editing programs allow the user to mark looping points and
then save these in the Ô¨Åle. GEN1 will load this information as part of the function
table, and Csound provides the loscil opcode family to read these tables, which
can also be multichannel. The opcode will loop the sound as speciÔ¨Åed in the saved
data. It is also possible to save the base frequency of the recorded sample in the
soundÔ¨Åle header, which is also read by GEN1. The frequency control in loscil
will be able to use this information to transpose the Ô¨Åle correctly according to this
information.
If it is not convenient to edit and save loop points with external software, we can
use the flooper opcode family to deÔ¨Åne looping points. The advantage here is
that these opcodes can crossfade the loop points. This means that the end of the loop
overlaps with the beginning, generally creating a smooth join. The loop points and
cross-fade time can be changed during performances with flooper2, which also
allows different types of looping (normal, backwards, and back-and-forth). These
opcodes feature a playback speed control (which is equivalent to the si parameter
discussed above), and can play tables forwards or backwards (negative si).
Noise generators
In order to generate non-pitched sounds, we can avail of a set of noise generators.
There are three classic opcodes that implement this functionality: rand, randh,
and randi. These use a basic pseudo-random number generator to output white and
bandlimited noise. White noise, generated by rand, has a theoretical Ô¨Çat frequency
response, containing an inÔ¨Ånite number of components with the same weight from
0 Hz to the Nyquist frequency. The bandlimited generators randh and randi,
will periodically draw a new random number, according to a frequency control,
holding it or interpolating it linearly to the next value, respectively. Both of them
218
12 Classic Synthesis
have less energy in the higher part of the spectrum. The result is slightly different,
however: the interpolating version will suppress high frequencies more audibly than
the sample-and-hold one (Fig. 12.7).
xres rand xamp [, iseed] [, isel] [, ioffset]
xres randh xamp, xcps [, iseed] [, isize] [, ioffset]
xres randi xamp, xcps [, iseed] [, isize] [, ioffset]
The actual numbers output by these generators are always the same sequence,
starting from the same point. If we want a different set of values, then we need to
seed the generators. This can be done by passing a different number to the iseed
parameter, or by making the opcode use the current system time for this. These op-
codes can use either the default 16-bit noise generator (isel = 0) or a more pre-
cise 31-bit algorithm (isel = 1). An offset can optionally be given (ioffset),
which will be added to the random value output.
Fig. 12.7 The output spectra of the three classic noise generators: rand (top), randh (middle),
and randi (bottom)
In addition to white noise, it is possible to generate approximations to pink noise.
This is a type of signal whose spectral envelope follows a 1
f pattern, inversely
proportional to frequency. Two opcodes provide this functionality: pinkish and
pinker. The Ô¨Årst one operates in a similar way to the classic noise generators in
that it uses a pseudo-random sequence that can be seeded, and it provides an op-
tion of three methods of operation. The other opcode is an implementation of Stefan
Wenzel‚Äôs algorithm, and it does not have any parameters (a normalised signal, -1 to
12.2 Source-ModiÔ¨Åer Methods
219
1, is generated). pinker is very close to having a 1
f , and does not suffer from a
periodicity which can happen with pinkish.
If a higher level of conÔ¨Ådence that the sequence is random is required it is pos-
sible to use the urandom opcode, which uses other timed activities on the host
computer, such as key strokes, network packets and interrupts, to increase the ran-
domness.
12.2.2 ModiÔ¨Åers
The typical modiÔ¨Åer for an arbitrary source is called a Ô¨Ålter. These are processing
units designed to amplify or suppress parts of the spectrum. Digital Ô¨Ålters work
by delaying signals by small amounts, and combining these with different scaling
amounts. This process can involve the re-injection of the Ô¨Ålter output back into
its input (with a certain delay), in which case we have a feedback Ô¨Ålter. If there
is no such signal path, then we call it a feedforward Ô¨Ålter. The amount of delay
used can vary, from a single to several samples, and this is one of the aspects that
will determine the Ô¨Ålter characteristics. The other is the scaling values associated
with each delayed signal. Typically, a feedback Ô¨Ålter will have delays of one or two
samples, and feedforward Ô¨Ålters will need longer delays.
The operation of a Ô¨Ålter can be quite complex to describe, but at its heart, it is
controlled by a simple principle: signals will sum up constructively or destructively
when in or out of phase. Two sound waves of the same frequency are in phase if
their starting point is aligned, otherwise they are out of phase. In the simple case of a
sinusoid, if the signals are completely out of phase, they will destructively interfere
with each other. This is the case when one of them is delayed by 1
2 cycle: they
will have opposite signs. If the waves have the same amplitude, they will cancel
each other out. Conversely, if they are in phase, they will add up to twice their
amplitude. In between these two extremes, out-of-phase signals will interfere with
each other by varying amounts. By using delays and scaling, Ô¨Ålters can introduce
areas of ampliÔ¨Åcation and suppression at different frequencies in the spectrum.
This is simple to observe in feedforward Ô¨Ålters. Consider the simple case where
we combine one signal with itself delayed by one sample (Fig. 12.8). In this case,
certain parts of the spectrum will add up constructively, while others will be sup-
pressed. To assess this, we can use sinusoidal waves of different frequencies. Take a
cosine wave of frequency 0 and amplitude 1: its digital representation consists of the
sequence of samples {1,1,1,1,1,...}. If we pass it through our Ô¨Ålter, the resulting
sequence will be {1,2,2,2,2,2,...}; the signal is ampliÔ¨Åed. At the other side of the
spectrum, a cosine wave at the Nyquist frequency is an alternation of positive and
negative samples, {1,‚àí1,1,‚àí1,1,‚àí1,...}. In this case, the output will be always 0,
as the signal is completely out of phase with its delayed path. In between these two
extremes, there is an increasing amount of attenuation, from 0 Hz upwards. This
principle can be extended to feedback Ô¨Ålters, but in that case it is not possible to
provide a simple analysis such as the one in Fig. 12.8.
220
12 Classic Synthesis
1, 1, 1, 1,...
- 1-sample delay
?
- i -
+
1, 2, 2, 2,...
1,-1, 1,-1,...
- 1-sample delay
?
- i -
+
1, 0, 0, 0,...
Fig. 12.8 Two digital cosine waves, at 0 Hz (top) and Nyquist (bottom), being fed to a Ô¨Årst-order
feedforward Ô¨Ålter. The Ô¨Ålter lets all of the 0 Hz signal through, but blocks the one at the Nyquist
frequency
Frequency response, Ô¨Ålter types and parameters
Filters can be described by their frequency response, which indicates how the input
signal is modiÔ¨Åed at various frequencies in the spectrum [63]. In addition to the
amplitude changes imposed, a Ô¨Ålter also affects the phase of its input, delaying it
by various amounts. The frequency response of a Ô¨Ålter is made up of its amplitude
and phase responses. We can classify Ô¨Ålters in general terms by the shape of their
response. In terms of amplitude, we have
‚Ä¢
low-pass: low-frequency components are passed with little alteration, and high-
frequency components are attenuated.
‚Ä¢
high-pass: low-frequency components are suppressed, high-frequency compo-
nents are passed.
‚Ä¢
band-pass: low- and high-frequency components outside a certain band are cut.
‚Ä¢
band-reject: components inside a certain band are attenuated.
‚Ä¢
all-pass: all components are passed with the same amplitude.
A plot of low-, high- and band-pass Ô¨Ålter amplitude responses is shown in
Fig. 12.9. The phase response of a Ô¨Ålter can be of two types:
‚Ä¢
linear: the same delay is imposed at all frequencies (phases are linearly shifted).
‚Ä¢
non-linear: frequencies are delayed by different amounts.
Linear phase responses are a feature of some feedforward Ô¨Ålters, whereas feed-
back types are non-linear with respect to phase. Generally, in musical applications,
we will be interested in the amplitude response of Ô¨Ålters, and less so in their phase
response. An exception is the case of all-pass Ô¨Ålters, where the amplitude response
does not change with frequency. In this case, we will be interested in the delays
imposed at different frequencies. Also, for speciÔ¨Åc applications, we might need to
ensure that the phase response is linear, in which case we have to be careful when
designing a Ô¨Ålter for them.
Filters can also be classiÔ¨Åed by their order. In the case of digital Ô¨Ålters, this is
measured by the delays used. So, for instance, if we only use a one-sample delay (as
12.2 Source-ModiÔ¨Åer Methods
221
Fig. 12.9 Amplitude response plots of low- (top), high- (middle) and band-pass (bottom) Ô¨Ålters.
The dash lines indicate the cut-off/centre frequencies.
in the example above), the Ô¨Ålter is Ô¨Årst-order; a second-order Ô¨Ålter has delays of up
to two samples, and so on. This is also called the Ô¨Ålter length, especially in the case
of feedforward Ô¨Ålters. For feedback Ô¨Ålters, in general the effect of increasing the
Ô¨Ålter order is to make it have a steeper roll-off in its amplitude response curve. The
roll-off describes the transition between the pass band (the region in the spectrum
where all frequency components are not modiÔ¨Åed) and the stop band (where the
spectrum is attenuated).
Feedback Ô¨Ålters are the most common types used in musical applications, as they
have controls that can be varied over time, and are very intuitive to use. They come
in different forms, which tend to have speciÔ¨Åc characteristics, determining the shape
of their frequency response, which is also controlled by the Ô¨Ålter parameters. The
most common of these are
‚Ä¢
tone control: Ô¨Årst-order low-pass or high-pass with a gentle amplitude response
curve. The sole Ô¨Ålter parameter is cutoff frequency. This determines the point
in the spectrum between the pass band and the stop band. Examples of these in
Csound are tone and atone.
‚Ä¢
resonators: second-order band-pass, which can have sharp resonances depend-
ing on parameters. These Ô¨Ålters have centre frequency and bandwidth controls,
which deÔ¨Åne the characteristics of the amplitude response. In Csound, the op-
codes reson, resonr and resonz implement this design.
222
12 Classic Synthesis
‚Ä¢
low-pass resonant: second- or fourth-order Ô¨Ålters with a resonant peak. They
feature cut-off frequency and resonance controls. In Csound, we have moogladder,
moogvcf, and lpf18, among others, as examples of this type.
‚Ä¢
Butterworth: classic design with a maximally Ô¨Çat pass band, in low-, high-,
band-pass and band-reject forms. Their controls are cut-off or centre frequency,
and bandwidth (in the case of band-pass and band-reject types). The butter*
family of Ô¨Ålter opcodes in Csound implements this type as second-order sections.
‚Ä¢
equalisers: equaliser Ô¨Ålters are generally band-pass/band-reject designs with a
characteristic all-pass behaviour outside their region of boost/attenuation. They
often have a gain control, in addition to centre frequency and bandwidth, which
controls whether the Ô¨Ålter cuts or ampliÔ¨Åes a particular portion of the spectrum.
In Csound, this type of Ô¨Ålter is implemented in eqfil.
Some Ô¨Ålters will have a Q control in place of bandwidth or resonance. This pa-
rameter can be deÔ¨Åned as
Q = f
B
(12.4)
where f is the Ô¨Ålter frequency (centre or cutoff, depending on the type), and B is
the bandwidth of the pass- or reject-band, or resonance region. The Q parameter is
inversely proportional to the width of the Ô¨Ålter band or resonance region. By keeping
the Q constant, the bandwidth will vary with frequency, which can have signiÔ¨Åcant
importance in musical applications.
Impulse response
A Ô¨Ålter can also be classiÔ¨Åed by its impulse response (IR), which is its output when
fed with a single sample impulse (a full amplitude sample followed by zeros). Feed-
forward types are called Finite Impulse Response (FIR), because the IR will even-
tually be zero after the impulse has circulated through all the delays. On the other
hand, feedback makes the Ô¨Ålter feature an inÔ¨Ånite impulse response, and so these
are called IIR Ô¨Ålters. This is because the impulse will keep being re-injected into
the process, and, theoretically, the output will never be zero. The behaviour of the
IR of feedback Ô¨Ålters is very important: if it never decays, the Ô¨Ålter is considered
unstable as its output will continue growing until it exceeds the numerical range of
the system. A decaying IR will eventually approach zero.
More generally, IRs can be used to describe a linear time-invariant (LTI) system,
and are used to implement feedforward Ô¨Ålters that represent it. For instance, if we
record the IR of a room, we can use it to impart its characteristics into an arbitrary
sound via an FIR Ô¨Ålter. In this case, the Ô¨Ålter length is equivalent to the IR size, and
each sample of the IR is used as a scaling factor for each Ô¨Ålter delay. This process is
called convolution, and it can be very useful for reverberation and other applications
where a Ô¨Åxed-parameter (‚Äútime-invariant‚Äù) Ô¨Ålter is required.
12.2 Source-ModiÔ¨Åer Methods
223
Multiple Ô¨Ålters
Multiple Ô¨Ålters can be connected in two ways: serially (cascade) or in parallel. In the
Ô¨Årst form, the output of one Ô¨Ålter is sent to the input of the next, making the combi-
nation a higher-order Ô¨Ålter. For instance, we can make a fourth-order Ô¨Ålter, with its
associated steeper roll-off, from a series connection of two identical second-order
sections. Other applications of serial Ô¨Ålters include equaliser Ô¨Ålterbanks, where each
Ô¨Ålter is set to cover a speciÔ¨Åc area of the spectrum. Parallel Ô¨Ålter connections are
made by feeding the same input to various Ô¨Ålters, and mixing their output. These
can also be used to construct Ô¨Ålterbanks that implement a more complex amplitude
response with various peaks in the spectrum, with band-pass Ô¨Ålter types.
12.2.3 Design Example 1: Analogue Modelling
Analogue electronic musical instruments have attracted a lot of interest in recent
years. In particular, the possibility of recreating their sound in the digital domain has
been a topic of research in musical signal processing. These instruments have been,
for the most part, constructed with source-modiÔ¨Åer designs, following the pattern
of connecting oscillators and noise generators to Ô¨Ålters, whose parameters can be
controlled by envelopes. The classic Minimoog synthesiser is based on this: two or
three oscillators, noise and external sources are sent into a mixer, whose output is
shaped by a low-pass resonant Ô¨Ålter. Two envelope generators are used, one for the
Ô¨Ålter frequency, and another for the amplitude.
Such instruments can be easily modelled with Csound. Virtual analogue oscil-
lators exist in the form of the vco and vco2 opcodes. Models of classic Ô¨Ålters
such as the Moog ladder and state variable (moogvcf, moogladder, svfilter
and statevar) are also available. In addition to these, other components can be
modelled from scratch or using unit generators provided by the system.
For instance, we would like to design an envelope following the classic attack-
decay-sustain-release (ADSR) design, which closely models how it might be imple-
mented in an analogue synthesiser. In these instruments, the envelope is triggered
by a voltage gate signal: when this is high, the envelope runs; and when this is low,
it releases. We can use the reference values 1 and 0 for high and low, and use logic
to move from one stage to another (from attack to decay, and to sustain). The ac-
tual envelope can be constructed by using a portamento opcode portk, which goes
smoothly from one value to another over a given time. This is in fact a Ô¨Årst-order
low-pass Ô¨Ålter (like tone), which acts on control signals. In order to allow an in-
strument to trigger the release stage on note-off, we use the opcode xtratim to
extend the duration for the release time. With these ideas, we can construct a UDO,
shown in listing 12.2.
Listing 12.2 Analogue modelling ADSR envelope UDO
/******************************************
224
12 Classic Synthesis
ksig ADSR kmax,iatt,idec,ksus,irel,ktrig
kmax - max amplitude after attack
iatt - attack time
idec - decay time
ksus - sustain amplitude
irel - release time
ktrig - trigger signal
*******************************************/
opcode ADSR,k,kiikik
kmax,iatt,idec,ksus,irel,ktrig xin
xtratim irel
ktime init 0
kv init 0
iper = 1/kr
if (ktrig == 1) then
ktime = ktime + iper
if ktime < iatt then
kt
= iatt
kv = kmax
else
kt = idec
kv = ksus
endif
else
kt = irel/8
kv = 0
ktime = 0
endif
kenv
portk
kv, kt
xout
kenv
endop
A basic analogue modelling instrument following the Minimoog structure can
now be realised with this envelope generator, the vco2 opcode and the moogladder
Ô¨Ålter. Listing 12.3 shows the code for this instrument, which plays a chromatic scale.
Listing 12.3 Analogue modelling instrument example
instr 1
ktrig = (release() == 1 ? 0 : 1)
iatt1 = 0.01
idec1 = 0.1
isus1 = 0.8
irel1 = 0.1
kenv1 ADSR p4,iatt1,idec1,isus1,irel1,ktrig
iatt2 = 0.1
idec2 = 0.2
12.2 Source-ModiÔ¨Åer Methods
225
isus2 = 0.4
irel2 = 0.05
kenv2 ADSR 1,iatt2,idec2,isus2,irel2,ktrig
a1 vco2 0dbfs/3, p5
a2 vco2 0dbfs/3, p5*1.005
a3 vco2 0dbfs/3, p5*.995
a4 moogladder a1+a2+a3, p5*6*(1+kenv2), 0.7
out a4*kenv1
endin
i1 = 0
while i1 < 12 do
schedule(1,i1,1,i1/12,cpspch(8+i1/100))
i1 += 1
od
12.2.4 Design Example 2: Channel Vocoder
The channel vocoder is a very interesting music instrument design, which was orig-
inally developed by the telecommunications industry as means of encoding speech
[36]. It was the Ô¨Årst breakthrough in the reproduction of speech using electronic
means. The vocoder operates by Ô¨Årst carrying out an analysis of signal amplitude in
separate bands of the spectrum. The information obtained by this analysis is used
to resynthesise the signal by applying it to matched synthesis channels that oper-
ate in the same bands. The excitation source for the synthesis component is gener-
ally based on broad-bandwidth oscillators, but this can be substituted by arbitrary
spectrum-rich sounds. This arrangement performs reasonably well for vocal sig-
nals of pitched nature (the so-called voiced signals), mostly represented by vowels
and semivowels [48]. It is possible to use an added noise generator for non-pitched
sounds, represented by some of the consonants, to improve the overall quality of the
reproduced sound. However, as a speech spectrum analyser, the channel vocoder
was superseded for engineering applications. It did Ô¨Ånd, however, a distinct place
in music applications. The vocoder still features as an instrument in various types
of electronic music. It has an ability to blend vocal and instrumental sounds (when
these replace the excitation oscillators) into something of an other-worldly quality.
There are various ways to realise the vocoder in Csound. The simplest is to decide
on an analysis/synthesis channel (or band) design and then apply as many of these as
we need across the spectrum. There are three elements to a vocoder band: a Ô¨Ålter for
the analysis signal, another one for the excitation signal, and a means of controlling
the amplitude of the band. This is done by the balance opcode, which controls
the level of one signal by comparing it to another, matching the two. It is a type
of envelope follower that can apply the energy detected to the signal being output
at each one of the vocoder bands. The Ô¨Ålter needs to be reasonably selective, so
226
12 Classic Synthesis
that it can be focused on a given frequency. For this job, fourth-order Butterworth
Ô¨Ålters are a good choice. The code for a vocoder band is shown in listing 12.4. It
employs two butterbp Ô¨Ålters in cascade for each of the excitation and analysis
signal paths, and the balancing unit is used to match the output level to the energy
detected at that band (Fig. 12.10).
excitation
?
Ô¨Ålter
?
analysis
?
Ô¨Ålter

balance
?
Fig. 12.10 A single band (channel) of a vocoder
Listing 12.4 Vocoder band UDO
/************************
asig VocBand as,an,kfreq,kbw
as - excitation signal
an - analysis signal
kfreq - band frequency
kbw - bandwidth
*************************/
opcode VocBand,a,aakk
as,an,kf,kbw xin
xout(balance(butterbp(
butterbp(as,kf,kbw),kf,kbw),
butterbp(
butterbp(an,kf,kbw),kf,kbw)))
endop
With this in hand, we have the choice of employing these opcodes directly in
an instrument, which would Ô¨Åx the number of bands used, or we could possibly
go one step further to make this variable. In this case, we can use recursion as
a programming strategy to build up a bank of vocoder bands, whose number and
spacing can be modiÔ¨Åed by the user. These start at a minimum frequency and extend
up to a maximum, and are spaced at even musical intervals. For this, the expression
to calculate the band spacing is
fn = fmin
! fmax
fmin
" N‚àí1
n‚àí1
(12.5)
12.2 Source-ModiÔ¨Åer Methods
227
where n is the band number, fmin, fmax, and fn are the max, min and band frequen-
cies, and N is the number of bands. We use a Ô¨Åxed Q parameter to make sure each
band is perceptually the same size as well. The full code is shown in listing 12.5.
Listing 12.5 Channel vocoder UDO
/******************************************
asig Vocoder as,an,kmin,kmax,kq,ibnd
as - excitation signal
an - analysis signal
kmin - lowest band frequency
kmax - highest band frequency
kq - vocoder band Q
ibnd - number of bands
*******************************************/
opcode Vocoder, a, aakkkpp
as,an,kmin,kmax,kq,ibnd,icnt
xin
if kmax < kmin then
ktmp = kmin
kmin = kmax
kmax = ktmp
endif
if kmin == 0 then
kmin = 1
endif
if (icnt >= ibnd) goto bank
abnd
Vocoder as,an,kmin,kmax,kq,ibnd,icnt+1
bank:
kfreq = kmin*(kmax/kmin)ÀÜ((icnt-1)/(ibnd-1))
kbw = kfreq/kq
ao VocBand as,an,kfreq,kbw
amix = ao + abnd
xout amix
endop
The vocoder UDO can be used in a variety of settings. For instance, we can use
it to resynthesis speech, as originally designed. In this case, we should use an ap-
propriate excitation source, such as a classic sawtooth wave (from vco or vco2),
and we can also track the pitch of the voice and its envelope to control the oscil-
lator fundamental frequency and amplitude, respectively. In listing 12.6, we show
a simple instrument example that does this, using plltrack to estimate the pitch
and a combination of rms and port to control the overall envelope of the sound.
This instrument can be modiÔ¨Åed to use other types of excitation sources, to create a
cross-synthesis blend with the analysis sound.
Listing 12.6 Vocoder instrument example
instr 1
228
12 Classic Synthesis
S1 = "fox.wav"
imin = 100
imax = 10000
asig diskin2 S1,1, 0,1
ap,aloc plltrack asig, 0.1
krms port rms(asig), 0.01
anoi vco krms,ap,1,0
aout Vocoder anoi,asig,imin,imax,25,32
outs aout,aout
endin
12.3 Distortion Synthesis Methods
Distortion techniques are based on the non-linear modiÔ¨Åcation of a basic sinusoid
waveform. They try to address the key question of how to generate complex time-
evolving spectra, composed of discrete components (eq. 12.1). An elegant solution
to this problem is to Ô¨Ånd a way of combining a few simple sources (i.e. sine wave
oscillators) to generate many partials. This is the approach taken by distortion syn-
thesis. In this section, we will survey these techniques with their associated Csound
examples.
12.3.1 Summation Formulae
Closed-form summation formulae provide several possibilities for generating com-
plex spectra. They take advantage of well-known expressions that can represent
arithmetic series, such as the harmonic series, in a compact way. In fact, it is fair to
say that all distortion techniques implement speciÔ¨Åc closed-form summation formu-
lae. We will be concentrating here on those that stem directly from simple closed-
form solutions to the harmonic series.
Bandlimited pulse
The general case of eq. 12.1 can be simpliÔ¨Åed considerably, if we constrain to certain
conditions. An example of this is a spectrum made up of harmonic components
added up with the same weight [131]:
s(t) = 1
N
N
‚àë
k=1
cos(kœâ0)
(12.6)
where œâ0 = 2œÄ ft. This produces what we call a bandlimited pulse.
12.3 Distortion Synthesis Methods
229
We can synthesise this spectrum by taking into account one of the best known
closed-forms of an arithmetic series:
N
‚àë
k=‚àíN
rk = r‚àíN 1‚àír2N+1
1‚àír
(12.7)
Using this we get [32]:
1
N
N
‚àë
k=1
cos(kœâ0) = 1
2N √ó
%sin((2N +1) œâ0
2 )
sin( œâ0
2 )
‚àí1
&
(12.8)
with œâ0 = 2œÄ f0t, and f0 the fundamental frequency in Hz. The parameter N de-
termines the number of harmonics. In this, and in the subsequent formulae in this
section, the relevant synthesis expression is on the right-hand side; the left-hand
expansion shows the resulting spectrum.
The only issue here is the possible zero in the denominator, in which case, we
can substitute 1 for the whole expression (as a simple measure; a full solution to
the problem requires more complicated logic). A sample Csound example from Ô¨Årst
principles is shown below. We will use a phasor to provide an index so we can look
up a sine wave table. Then we just apply the expression above.
Listing 12.7 bandlimited pulse UDO
/*********************************
asig Blp kamp,kfreq
kamp - amplitude
kfreq - fundamental frequency
**********************************/
opcode Blp,a,kki
setksmps 1
kamp,kf
xin
kn = int(sr/(2*kf))
kph phasor kf/2
kden tablei kph,-1,1
if kden != 0 then
knum tablei kph*(2*kn+1),-1,1,0,1
asig = (kamp/(2*kn))*(knum/kden - 1)
else
asig = kamp
endif
xout asig
endop
Because of the extra check, we need to run the code with a ksmps block of 1, so
we can check every sample (to avoid a possible division by zero). This code can be
modiÔ¨Åed to provide time-varying spectra (by changing the value of kn). With this,
we can emulate the effect of a low-pass Ô¨Ålter with variable cut-off frequency. The
230
12 Classic Synthesis
algorithm used in Blp is implemented internally in Csound by the buzz opcode,
which is, as such, more efÔ¨Åcient than the UDO version.
Generalised Summation Formulae
Another set of closed-form summation formulae allows for a more Ô¨Çexible control
of synthesis [91]. In particular, these give us a way to control spectral roll-off and to
generate inharmonic partials. The synthesis expression for bandlimited signals is
N
‚àë
k=1
ak sin(œâ +kŒ∏) =
sin(œâ)‚àíasin(œâ ‚àíŒ∏)‚àíaN+1(sin(œâ +(N +1)Œ∏)‚àíasin(œâ +NŒ∏))
1‚àí2‚àóacos(Œ∏)+a2
(12.9)
where œâ = 2œÄ f1t and Œ∏ = 2œÄ f2t , with f1 and f2 as two independent frequency
values in Hz. N is the number of components, as before, and a is an independent
parameter controlling the amplitudes of the partials.
Here, by modifying a and N, we can alter the spectral roll-off and bandwidth,
respectively. Time-varying these parameters allows the emulation of a low-pass Ô¨Ålter
behaviour. By choosing various œâ to Œ∏ (f1 : f2) ratios, we can generate various types
of harmonic and inharmonic spectra. The only extra requirement is a normalising
expression, since this method will produce a signal whose gain varies with the values
of a and N:
'
1‚àía2
1‚àía2N+2
(12.10)
Using the synthesis equation 12.9 and its corresponding scaling expression, the
following Csound opcode can be created, which produces components up to the
Nyquist frequency by setting N accordingly (listing 12.8).
Listing 12.8 Generalised summation-formulae UDO
/*********************************
asig Blsum kamp,kfr1,kfr2,ka
kamp - amplitude
kfr1 - frequency 1 (omega)
kfr2 - frequency 2 (theta)
ka - distortion amount
*********************************/
opcode Blsum,a,kkkki
kamp,kw,kt,ka xin
kn = int(((sr/2) - kw)/kt)
aphw phasor kw
12.3 Distortion Synthesis Methods
231
apht phasor kt
a1 tablei aphw,-1,1
a2 tablei aphw - apht,-1,1,0,1
a3 tablei aphw + (kn+1)*apht,-1,1,0,1
a4 tablei aphw + kn*apht,-1,1,0,1
acos tablei apht,-1,1,0.25,1
kpw pow ka,kn+1
ksq = ka*ka
aden = (1 - 2*ka*acos + ksq)
asig = (a1 - ka*a2 - kpw*(a3 - ka*a4))/aden
knorm = sqrt((1-ksq)/(1 - kpw*kpw))
xout asig*kamp*knorm
endop
If we are careful with the spectral roll-off, a much simpler non-bandlimited ex-
pression is available:
‚àû
‚àë
k=1
ak sin(œâ +kŒ∏) = sin(œâ)‚àíasin(œâ ‚àíŒ∏)
1‚àí2‚àóacos(Œ∏)+a2
(12.11)
In this case, we will not have a direct bandwidth control. However, if we want to
know what, for instance, our -60 dB bandwidth would be, we just need to know the
maximum value of k for ak > 0.001. The normalising expression is also simpler:
(
1‚àía2
(12.12)
The modiÔ¨Åed Csound code to match this expression is shown in listing 12.9.
Listing 12.9 Non-bandlimited generalised summation-formulae UDO
/*********************************
asig NBlsum kamp,kfr1,kfr2,ka
kamp - amplitude
kfr1 - frequency 1 (omega)
kfr2 - frequency 2 (theta)
ka - distortion amount
*********************************/
opcode NBlsum,a,kkkk
kamp,kw,kt,ka
xin
aphw phasor kw
apht phasor kt
a1 tablei aphw,-1,1
a2 tablei aphw - apht,itb,1,0,1
acos tablei apht,-1,1,0.25,1
ksq = ka*ka
asig = (a1 - ka*a2)/(1 - 2*ka*acos + ksq)
knorm = sqrt(1-ksq)
xout asig*kamp*knorm
232
12 Classic Synthesis
endop
12.3.2 Waveshaping
The technique of waveshaping is based on the non-linear distortion of the ampli-
tude of a signal [77, 5]. This is achieved by mapping an input, generally a simple
sinusoidal one, using a function that will shape it into a desired output waveform.
The amount of distortion can be controlled by a distortion index, which controls the
amplitude of the input signal.
Traditionally, the most common method of Ô¨Ånding such a function (the so-called
transfer function) has been through polynomial spectral matching. The main advan-
tage of this approach is that polynomial functions will precisely produce a bandlim-
ited matching spectrum for a given sinusoid at a certain amplitude.
However, the disadvantage is that polynomials also have a tendency to produce
unnatural-sounding changes in partial amplitudes, if we require time-varying spec-
tra. More recently, research has shown that for certain waveshapes, we can take
advantage of other common functions, from the trigonometric, hyperbolic etc. reper-
toire. Some of these can provide smooth spectral changes. We will look at the use
of hyperbolic tangent transfer functions to generate nearly bandlimited square and
sawtooth waves. A useful application of these ideas is in the modelling of analogue
synthesiser oscillators.
Hyperbolic tangent waveshaping
A simple way of generating a (non-bandlimited) square wave is through the use of
the signum() function, mapping a varying bipolar input. This piecewise function
outputs 1 for all non-zero positive input values, 0 for a null input and -1 for all
negative arguments. In other words, it clips the signal, but in doing so, it generates
lots of components above the Nyquist frequency, which are duly aliased. The main
cause of this is the discontinuity at 0, where the output moves from fully negative to
fully positive. If we can smooth this transition, we are in business.
The hyperbolic tangent is one such function that can be used instead of signum()
[71], as it has a smooth transition at that point but it also preserves some of its clip-
ping properties (see Fig. 12.11). If we drive this function with a sinusoidal input, we
will be able to produce a nearly bandlimited signal. How bandlimited will depend
on how hard we drive it, as higher input amplitudes will produce more and more
harmonics, and take less advantage of its smoothing properties. As with all types
of waveshaping, the amplitude of the input signal will determine signal bandwidth,
in a proportional way. If we want to keep a steady output amplitude, but vary the
spectrum, we will need to apply an amplitude-dependent scaling. This is generally
done by using a scaling function that takes the input amplitude as its argument and
12.3 Distortion Synthesis Methods
233
produces a gain that can be applied to the output signal. We can then refer to the
amplitude of the input sinusoid as the distortion index.
The code for general-purpose waveshaping is based on standard function map-
ping. It takes an input sinusoid, maps it using table lookup and then applies the
required gain, also obtained through table lookup.
Listing 12.10 Waveshaping UDO
/**********************************************
asig
Waveshape kamp,kfreq,kndx,ifn1,ifn2
kamp - amplitude
kfreq - frequency
kndx - distortion index
ifn1 - transfer function
ifn2 - scaling function
***********************************************/
opcode Waveshape,a,kkkiii
kamp,kf,kndx,itf,igf xin
asin oscili 0.5*kndx,kf
awsh tablei asin,itf,1,0.5
kscl tablei kndx,igf,1
xout awsh*kamp*kscl
endop
For hyperbolic waveshaping, we will need to provide two function tables, for the
transfer (tanh) and the scaling functions, shown in listing 12.11. The Ô¨Årst Csound
GEN draws tanh(x), over ¬± p
50, and the second automatically generates a scaling
function based on the previous table. This is necessary to keep the overall amplitude
level, as the input gain changes with the distortion index.
To keep aliasing at bay, the index of distortion (kndx) can be estimated roughly
as kndx = 10000/(kf*log10(kf)).
Listing 12.11 Hyperbolic tangent waveshaping function tables
f2 0 16385 "tanh" -157 157
f3 0 8193 4 2 1
If we would like to generate a sawtooth wave instead, we could take our square
signal and apply the following expression:
saw(t) = square(œâ)(cos(œâ)+1)
(12.13)
By heterodyning it with a cosine wave, we can easily obtain the missing even
components that make up the sawtooth signal. There will be a slight disparity in
the amplitude of the second harmonic (about 2.5 dB), but the higher harmonics
will be nearly as expected. This is an efÔ¨Åcient way of producing a sawtooth wave
(listing 12.12) [71].
Listing 12.12 Sawtooth wave oscillator based on waveshaping
/**********************************************
234
12 Classic Synthesis
Fig. 12.11 Hyperbolic tangent waveshaping. The plot on the top shows the input to the waveshaper,
whose transfer function is shown on the bottom left, and the resulting output on the right
asig
Sawtooth kamp,kfreq,kndx,ifn1,ifn2
kamp - amplitude
kfreq - frequency
kndx - distortion index
ifn1 - transfer function
ifn2 - scaling function
***********************************************/
opcode Sawtooth,a,kkkii
kamp,kf,kndx,itf,igf xin
amod oscili 1,kf,-1,0.25
asq Waveshape kamp*0.5,kf,kndx,-1,itf,igf
xout asq*(amod + 1)
endop
12.3.3 Frequency and Phase Modulation
Frequency and Phase Modulation (FM/PM), pioneered by John Chowning in the
early 1970s [26], are classic distortion techniques that have been used extensively
12.3 Distortion Synthesis Methods
235
in music. They are a special case of summation formulae that have a very straight-
forward implementation with two oscillators.
We will concentrate here on implementing PM, as it is the more Ô¨Çexible of the
two, and allows a number of combinations and variations of the basic principle.
FM/PM works by using one or more oscillators, the modulator(s), to modulate the
frequency or the phase of one or more carriers. Sinusoidal oscillators are generally
used for this.
The expression for the basic form of this technique, with one carrier, and one
modulator, is given by.
‚àû
‚àë
n=‚àí‚àû
Jn(k)cos(œâc +nœâm) = cos(œâc +ksin(œâm))
(12.14)
where Jn(k) are called Bessel functions of the Ô¨Årst kind, which will determine the
amplitude of each component in the spectrum; œâc = 2œÄ fct and œâm = 2œÄ fmt are the
carrier and modulator frequencies, respectively.
The value of these functions will vary with the k argument, which is called the
index of modulation. For low k, high-order Jn(k) are zero or close to zero. As the
index rises, these Bessel functions tend to increase, and then Ô¨Çuctuate between pos-
itive and negative values (see Fig. 12.12). This ‚Äòwobble‚Äô is the cause of the complex
spectral evolution observed in PM.
The spectrum of PM will be made up of the sums and differences of the carrier
and modulator frequencies (plus the carrier itself), scaled by the Bessel functions.
Each one of these fc ¬± fm frequencies is called a sideband, lying as it does on each
side of the carrier. Any cosine component on the negative side of the spectrum is
‚ÄòreÔ¨Çected‚Äô back on the positive side. The fc : fm ratio will determine whether the
spectrum is harmonic or inharmonic. The rule of thumb is that if it involves small
whole numbers, we will have harmonic partials, otherwise the spectral components
will not fuse to make an audible periodic waveform. The exact amplitude of each
component in the spectrum can be worked out from equation 12.14 above and the
values of Jn(k) for a given k. The spectrum is non-bandlimited, but most of the
energy will be concentrated in the Ô¨Årst k +1 sidebands.
An implementation of the PM algorithm is seen in listing 12.13. For time-varying
spectra, as with any of the other distortion techniques, we have to change the mod-
ulation amount by manipulating the index.
Listing 12.13 PM synthesis UDO
/**********************************************
asig
PM kamp,kfc,kfm,kndx
kamp - amplitude
kfc - carrier frequency
kfm - modulation frequency
kndx - distortion index
***********************************************/
opcode PM,a,kkkk
kamp,kfc,kfm,kndx xin
236
12 Classic Synthesis
Fig. 12.12 Bessel functions of orders 0 to 5. Note how they oscillate between positive and negative
values as the index of modulation increases
acar phasor kfc
amod oscili kndx/(2*$M_PI),kfm
apm
tablei acar+amod,-1,1,0.25,1
xout apm*kamp
endop
Another way we could package PM synthesis is by using the Yamaha DX series
principle of operators. These are a combination of an oscillator, whose phase can be
modulated, with an ADSR envelope. In this case, we design a UDO that models the
operator, and then we can connect these together in another opcode or instrument.
Listing 12.14 PM operator UDO
/******************************************
asig PMOp kamp,kfr,apm,iatt,idec,isus,irel[,ifn]
kamp - amplitude
kfr - frequency
apm - phase modulation input
iatt - attack
idec - decay
12.3 Distortion Synthesis Methods
237
isus - sustain
irel - release
ifn - optional wave function table (defaults to sine)
*********************************************/
opcode PMOp,a,kkaiiiij
kmp,kfr,apm,
iatt,idec,
isus,irel,ifn xin
aph phasor kfr
a1
tablei aph+apm/(2*$M_PI),ifn,1,0,1
a2
madsr iatt,idec,isus,irel
xout
a2*a1*kmp
endop
This operator form of PM is extremely versatile, as we can arrange these opcodes
in any modulation combination, including complex [114, 24] and feedback [123]
modulation (ksmps=1 is needed for this). Each operator has its own envelope, so we
can make time-varying spectra very easily. Modulator envelopes will control tim-
bre, while carrier envelopes control amplitude. An equivalent process to the simple
PM in the PM UDO of listing 12.13 can easily be implemented with two operators.
This has the added bonus that we have envelopes included, as we demonstrate in
listing 12.15.
Listing 12.15 PM operator UDO example
instr 1
amod PmOp p6,p5,a(0),0.1,0.1,0.5,0.1
acar PmOp p4,p5,amod,0.01,0.1,0.9,0.1
out acar
endin
schedule(1,0,1,0dbfs/2,440,7)
Asymmetrical PM Synthesis
An interesting variation on FM/PM synthesis is Asymmetrical PM [98]. In this for-
mulation, the original PM model is ring-modulated by an exponential signal. This
has the effect of introducing a new parameter controlling spectral symmetry that al-
lows the peaks to be dislocated above or below the carrier frequency. The expression
for this technique (excluding a normalisation factor) is
‚àû
‚àë
n=‚àí‚àû
rnJn(k)sin(œâc +nœâm) =
exp(0.5k(r ‚àí1
r )cos(œâm))√ósin(œâc +0.5k(r + 1
r )sin(œâm))
(12.15)
238
12 Classic Synthesis
where, as before, Jn(k) are called Bessel functions of the Ô¨Årst kind; œâc = 2œÄ fct and
œâm = 2œÄ fmt are the carrier and modulator frequencies, respectively.
The new parameter r is the symmetry control, r < 1 pulling the spectral peak
below the carrier frequency œâc and r > 1 pushing it above. It is a very nice feature
which can be added at the expense of a few multiplies and a couple of extra table
lookups (for the cosine and the exponential). Note that what we have here is actually
the ring modulation of a waveshaper output (using an exponential transfer function)
and the PM signal. This is a nice way of tying up two distortion techniques together.
Implementing this is not too complicated. The exponential expression needs nor-
malisation, which can be achieved by dividing it by exp(0.5k[r ‚àí1
r ]). When coding
this, we will draw up an exponential table from 0 to an arbitrary negative value
(say -50) and then look it up with a sign reversal (exp(‚àíx)). This allows us to use
the limiting table-lookup mechanism in case we have an overÔ¨Çow. Since the values
of exp() tend to have little variation for large negative values, limiting will not be
problematic.
Listing 12.16 Asymmetric FM UDO
/*********************************************
asig Asfm kamp,kfc,kfm,kndx,kR,ifn,imax
kamp - amplitude
kfc - carrier frequency
kfm - modulation frequency
kndx - distortion index
ifn - exp func between 0 and -imax
imax - max absolute value of exp function
**********************************************/
opcode Asfm,a,kkkkkii
kamp,kfc,kfm,knx,kR,ifn,imax
kndx = knx*(kR+1/kR)*0.5
kndx2 = knx*(kR-1/kR)*0.5
afm oscili kndx/(2*$M_PI),kfm
aph phasor kfc
afc tablei aph+afm,ifn,1,0,1
amod oscili kndx2, kfm, -1, 0.25
aexp tablei -(amod-abs(kndx2))/imx, ifn, 1
xout kamp*afc*aexp
endop
with the exponential function table (ifn) drawn from 0 to -imx (-50):
f5 0 131072 "exp" 0 -50 1
12.3 Distortion Synthesis Methods
239
12.3.4 Phase-Aligned Formant Synthesis
One of the most recent new methods of distortion synthesis is the Phased-Aligned
Formant (PAF) algorithm [102]. Here, we start with a desired spectral description
and then work it out as a ring modulation of a sinusoid carrier and a complex spec-
trum (with low-pass characteristics). The interest is in creating formant regions, so
we will use the sinusoid to tune a spectral bump around a target centre frequency.
The shape of the spectrum will be determined by its modulator signal, which in
turn is generated by waveshaping using an exponentially shaped transfer function.
So we have PAF, in its simplest formulation, as
‚àû
‚àë
n=‚àí‚àû
g|n| cos(œâc +nœâm) = 1+g
1‚àíg √ó f
! 2‚àög
1‚àíg sin
)œâm
2
*"
cos(œâc)
(12.16)
f(x) =
1
1+x2
(12.17)
g = exp( fc
B )
(12.18)
The waveshaper transfer function is f(x). The signal has bandwidth B, funda-
mental frequency œâm = 2œÄ fmt and formant centre frequency œâc = 2œÄ fct. To this
basic formulation, where we expect fc to be an integer multiple of fm, a means of
setting an arbitrary centre frequency is added (basically by using a pair of modula-
tors). In addition, the complete PAF algorithm provides a frequency shift parameter,
which, if non-zero, allows for inharmonic spectra.
The complete Csound code of a more or less literal implementation of PAF is
shown in listing 12.17.
Listing 12.17 PAF UDO
opcode Func,a,a
asig xin
xout 1/(1+asigÀÜ2)
endop
/**************************************
asig PAF kamp,kfun,kcf,kfshift,kbw
kamp - amplitude
kfun - fundamental freq
kcf - centre freq
kfshift - shift freq
kbw - bandwidth
***************************************/
opcode PAF,a,kkkkki
kamp,kfo,kfc,kfsh,kbw
xin
240
12 Classic Synthesis
kn = int(kfc/kfo)
ka = (kfc - kfsh - kn*kfo)/kfo
kg = exp(-kfo/kbw)
afsh phasor kfsh
aphs phasor kfo/2
a1 tablei 2*aphs*kn+afsh,-1,1,0.25,1
a2 tablei 2*aphs*(kn+1)+afsh,-1,1,0.25,1
asin tablei aphs, 1, 1, 0, 1
amod Func 2*sqrt(kg)*asin/(1-kg)
kscl = (1+kg)/(1-kg)
acar = ka*a2+(1-ka)*a1
asig = kscl*amod*acar
xout asig*kamp
endop
The waveshaping here is performed by directly applying the function, since there
are no GENs in Csound which can directly generate such a table. This is of course
not as efÔ¨Åcient as lookup, so there are two alternatives: write a code fragment to Ô¨Åll
a table with the transfer function, to be run before synthesis; or, considering that the
resulting distorted signal is very close to a Gaussian shape, use GEN 20 to create
one such wavetable. A useful exercise would be to reimplement the PAF generator
above with table-lookup waveshaping.
12.3.5 ModiÔ¨Åed FM Synthesis
ModiÔ¨Åed FM synthesis (ModFM) is based on a slight change in the FM/PM algo-
rithm, with some important consequences [72]. One form of the PM equation, when
cast in complex exponential terms, can look like this:
‚Ñú{eiœâc+iz cos(œâm)}
(12.19)
where ‚Ñú{x} is the real part of x.
If we apply a change of variable z = ‚àíik to the above formula, we will obtain the
following expression:
‚Ñú{eiœâc+k cos(œâm)} = ek cos(œâm) cos(œâc)
(12.20)
which, is the basis for the ModiÔ¨Åed FM synthesis formula; œâc = 2œÄ fct and œâm =
2œÄ fmt are the carrier and modulator frequencies, respectively.
One of the most important things about this algorithm is revealed by its expan-
sion:
12.3 Distortion Synthesis Methods
241
ek cos(œâm) cos(œâc) =
1
ek
+
I0(k)cos(œâc)+
‚àû
‚àë
n=1
In(k)[cos(œâc +nœâm)‚àícos(œâc ‚àínœâm)]
,
(12.21)
where In(k) are modiÔ¨Åed Bessel functions of the Ô¨Årst kind, and constitute the basic
(and substantial) difference between FM and ModFM. Their advantage is that (1)
they are unipolar and (2) In(k) > In+1(k),which means that spectral evolutions are
much more natural here.
Fig. 12.13 ModiÔ¨Åed Bessel functions of orders 0 to 5. Unlike the original Bessel functions, these
do not oscillate and are unipolar
In particular, the scaled modiÔ¨Åed Bessels do not exhibit the much-maligned
‚Äòwobble‚Äô seen in the behaviour of Bessel functions. That very unnatural-sounding
characteristic of FM disappears in ModFM. A plot of modiÔ¨Åed Bessel functions of
orders 0 to 5 is shown in Fig. 12.13.
There are several applications of ModFM (as there are of FM) as well as small
variations in its design. We will present here Ô¨Årst a basic straight implementation of
the algorithm. The Csound code uses table lookup to realise the exponential wave-
242
12 Classic Synthesis
shaper in the ModFM formula. Apart from that, all we require is two cosine oscilla-
tors, yielding a very compact algorithm (listing 12.18).
Listing 12.18 ModFM UDO
/*******************************************
asig ModFM kamp,kfc,kfm,kndx,ifn,imax
kamp - amplitude
kfc - carrier frequency
kfm - modulation frequency
kndx - distortion index
ifn - exp func between 0 and -imax
imax - max
absolute value of exp function
**********************************************/
opcode ModFM,a,kkkkiii
kamp,kfc,kfm,kndx,iexp,imx xin
acar oscili kamp,kfc,-1,0.25
acos oscili 1,kfm,-1,0.25
amod table -kndx*(acos-1)/imx,iexp,1
xout acar*amod
endop
With ModFM, it is possible to realise typical low-pass Ô¨Ålter effects, by varying
the index of modulation k. Also, by using the carrier fc and modulation frequency
fm as the centre of a formant and the fundamental, respectively, it is possible to
reproduce the effect of a band-pass Ô¨Ålter [70, 73]. In fact, a variant of the ModFM
implementation above with phase-synchronous signals can serve as a very efÔ¨Åcient
alternative to PAF and other formant synthesis techniques (such as FOF [112]). This
is show in listing 12.19.
Listing 12.19 ModFM formant synthesis UDO
/*******************************************
asig ModForm kamp,kfo,kfc,kbw,ifn,imax
kamp - amplitude
kfo - fundamental frequency
kfc - formant centre frequency
kbw - bandwidth
ifn - exp func between 0 and -imax
imax - max absolute value of exp function
**********************************************/
opcode ModForm,a,kkkkii
kamp,kfo,kfc,kbw,ifn,itm
xin
ioff = 0.25
itab = -1
icor = 4.*exp(-1)
ktrig changed kbw
if ktrig == 1 then
12.4 Additive Synthesis
243
k2 = exp(-kfo/(.29*kbw*icor))
kg2 = 2*sqrt(k2)/(1.-k2)
kndx = kg2*kg2/2.
endif
kf = kfc/kfo
kfin = int(kf)
ka = kf
- kfin
aph
phasor kfo
acos tablei aph, 1, 1, 0.25, 1
aexp table kndx*(1-acos)/itm,ifn,1
acos1 tablei aph*kfin, itab, 1, ioff, 1
acos2 tablei aph*(kfin+1), itab, 1, ioff, 1
asig = (ka*acos2 + (1-ka)*acos1)*aexp
xout asig*kamp
endop
This code synchronises the phase of the carrier and modulation signals, and for
this reason, we use a single phase source (aph) for all oscillators (which become
just table lookups). There are two sources (carriers) (acos1 and acos2), whose output
is mixed together, interpolated, to set the formant centre frequency more accurately
(as is done with PAF).
12.4 Additive Synthesis
Additive methods attempt to implement eq. 12.1 more or less faithfully [90]. In this
sense, they are a very powerful, however raw, way of generating new sounds. They
can also be quite simple in concept, but often demanding from a computational point
of view. The basic form of additive synthesis does not require special unit genera-
tors, only table oscillators and readers. In listing 12.20, we show an opcode that
represents a single partial. This can be used as a building block for an instrument,
by supplying it with an amplitude, frequency and two function tables containing
the envelopes for these parameters. A time counter is used to scan through these
envelope tables.
Listing 12.20 Additive synthesis partial UDO
/*************************************
asig Partial kamp,kfreq,ktime,ifa,iff
kamp - amplitude
kfreq - frequency
ktime - envelope time point (0 - 1)
ifa - amplitude function table
iff - frequency function table
**************************************/
opcode Partial,a,kkkii
244
12 Classic Synthesis
ka,kf,kt,ifa,iff xin
xout(oscili(ka*tablei:k(kt,ifa,1),
kf*tablei:k(kt,iff,1)))
endop
A complete example showing the use of this opcode is shown in listing 12.21.
Here we try to create an inharmonic spectrum, with some frequency bending as
the sound progresses. A plot of a segment of the output signal produced by this
instrument is shown on Fig. 12.14, where it is possible to see that the waveform
does not have an obvious periodic pattern. We use two exponential function tables:
for amplitude, a simple decaying envelope from 1 to
1
1000 (-60 dB); for frequency,
a downward bend from 1 to 0.9. In the instrument, partials traverse these envelopes
at different rates, which are linked to the overall sound duration. Each partial has its
own maximum amplitude and frequency, and we can scale all frequencies for each
instance with parameter 4. The mix of partials is smoothed by an overall envelope to
avoid any clicks at the start or end of a sound. To demonstrate it, the example plays
two instrument instances, with different durations and frequency scaling.
Listing 12.21 Additive synthesis example
i1 ftgen 1,0,16385,5,1,16384,0.001
i2 ftgen 2,0,16385,-5,1,16384,0.9
instr 1
ap[] init 8
ipf[] fillarray 440,480,590,610,700,850,912,990
ipa[] fillarray 0.8,0.9,0.3,0.7,0.6,0.5,0.1,0.2
kt = timeinsts()/p3
ap[0] Partial ipa[0],ipf[0]*p4,kt,1,2
ap[1] Partial ipa[1],ipf[1]*p4,1.1*kt,1,2
ap[2] Partial ipa[2],ipf[2]*p4,1.2*kt,1,2
ap[3] Partial ipa[3],ipf[3]*p4,1.3*kt,1,2
ap[4] Partial ipa[4],ipf[4]*p4,1.4*kt,1,2
ap[5] Partial ipa[5],ipf[5]*p4,1.5*kt,1,2
ap[6] Partial ipa[6],ipf[6]*p4,1.6*kt,1,2
ap[7] Partial ipa[7],ipf[7]*p4,1.7*kt,1,2
kcnt = 0
amix = 0
while kcnt < 8 do
amix += ap[kcnt]
kcnt += 1
od
out linen(amix*0dbfs/10,0.01,p3,0.01)
endin
schedule(1,0,20,1.5)
schedule(1,1,19,1)
12.4 Additive Synthesis
245
Fig. 12.14 A plot of a short segment of the output from listing 12.21
Implementing simple instruments with a limited number of partials is straightfor-
ward1. The difÔ¨Åculty starts when the number of components increases and also the
amplitude and frequency trajectories have to be individually speciÔ¨Åed. In these sit-
uations, we will need to approach the problem by manipulating partial parameters
programmatically, and/or using analytical methods to derive them. In the follow-
ing sections we will look at two applications of additive synthesis: one that takes a
programmatic route, and another that implements synthesis from analysis data.
12.4.1 A Tonewheel Organ Instrument
In a general way, pipe organs have used the principle of additive synthesis for cen-
turies. The idea of combining different registrations, in effect mixing the sound of
simple (although not exactly sinusoidal) sources to make a given sound, follows
exactly the same principles studied here. So an interesting application of these is
to reproduce a classic electronic organ design: the tonewheel instrument. This was
pioneered by the Hammond company [62], and it synthesises sound by the addition
of simple sources that are very close to sinusoids.
Each component is produced by a rotating wheel, which induces a current in an
electric pickup, generating a tone (therefore, it is a tonewheel). A note is produced
by summing up to nine of these, whose levels are controlled by a mixer (physically,
this is a set of sliders called drawbars). An organ can have up to 96 of these wheels
(arranged in semitones, covering eight octaves). Once the instrument is started, a
motor puts the tonewheels into motion. When a key is pressed, nine contacts are
made, placing the sound of the corresponding sources in the instrument‚Äôs nine main
audio busses, which are sent to the mixer.
1 Note that in this example we had to call each Partial opcode explicitly, outside a loop, as
explained in Section 5.2.3. For a variable, dynamic, number of partials, recursion can be used to
spawn parallel opcodes as shown in the vocoder example.
246
12 Classic Synthesis
We can try to follow this design quite faithfully. The Ô¨Årst step is to implement
the tonewheel mechanism, which can be modelled by a bank of oscillators. Since
the sound of these sources is going to be shared by all the notes in the instrument, it
makes sense to place them in a single global location, so we can use an array for that.
As already noted in earlier sections, recursion is a useful device to implement banks
of unit generators. In listing 12.22 we see the implementation of the tonewheels as a
UDO. This is an unusual opcode in that only a single instance of it is required in an
orchestra. It places its audio in the global array. The range of tonewheel frequencies
is from 32.7 to 7,901.91Hz.
Listing 12.22 Tonewheel mechanism model UDO
giwheels init 96
gawheels[]
init giwheels
/*******************************
ToneWheel iwheels
iwheels - number of tonewheels
***********************************/
opcode ToneWheel,0,io
ibnd,icnt xin
if icnt < ibnd-1 then
ToneWheel ibnd, icnt+1
endif
gawheels[icnt] oscili 1,cpspch(5+icnt/100)
endop
The following step is to implement the note contacts, which are made when a key
is pressed. Similarly, the selected tonewheels get added to a bus, which is shared by
the whole of the instrument, so we make it a global array of nine audio signals. The
important part here is to select the correct tonewheels, which are placed at speciÔ¨Åc
intervals above the fundamental, in semitones: 0, 19, 12, 24, 31, 36, 40, 43 and 48.
To simplify, we place these in an array for easy indexing. A UDO which models the
organ note is show in listing 12.23. The note to be played is relative to the tonewheel
scale (0-95).
Listing 12.23 Tonewheel note UDO
gkpart[] fillarray 0,19,12,24,31,36,40,43,48
gabus[] init 9
/*******************************************
Note inum
inum - note to be played (relative to tonewheel scale)
*******************************************/
opcode Note,0,i
inote xin
kcnt init 0
knote init 0
kcnt = 0
12.4 Additive Synthesis
247
while kcnt < 9 do
knote = inote+gkpart[kcnt]
if knote < giwheels
&& knote >= 0 then
gabus[kcnt] = gabus[kcnt] + gawheels[knote]
endif
kcnt += 1
od
endop
These two opcodes are responsible for modelling the complete tonewheel and
note mechanism. To complement the organ, we need to implement the mixer that
takes the drawbar controls and mixes up the nine busses accordingly. This can be ac-
complished by another UDO, which will also apply some compression to the signal,
depending on the conÔ¨Åguration of the drawbars and keys used. We assume that in-
strument 1 will be used to trigger the notes, and we check with the active opcode
how many instances of it are currently playing. This UDO is shown in listing 12.24.
Listing 12.24 Tonewheel mixer UDO
/**********************
asig Mixer kbars[]
kbars[] - drawbar levels(9)
**********************/
opcode Mixer,a,k[]
kbar[] xin
asig = 0
kcnt = 0
kscl = 0
while kcnt < 9 do
asig += gabus[kcnt]*kbar[kcnt]
gabus[kcnt] = 0
kscl += kbar[kcnt]
kcnt += 1
od
xout asig*0dbfs/(21+kscl*active:k(1))
endop
Complementing the model, we will add the typical vibrato/chorus effect, which
can be used to modify the organ sound. This is not strictly a part of the additive syn-
thesis mechanism, but a global processor that acts on the mixer output. The Ham-
mond chorus/vibrato is constructed using a very short (1.1 ms) modulated delay line.
The modulation wave is triangular, set at a Ô¨Åxed rate (6.87 Hz), and there are three
depth settings (45%, 66% and 100%). We implement this in digital form, trying to
model these features faithfully. Vibrato and chorus modes are offered; the difference
between the two is whether the original signal is mixed to the effect. The basis for
this effect will be discussed in more detail in Chapter 13. The effect UDO is shown
in listing 12.25.
248
12 Classic Synthesis
Listing 12.25 Delay-line vibrato/chorus UDO
ifn ftgen 2,0,16384,20,3,1
/***************************
asig VChorus ain,kdepth,ichorus
asig - input signal
kdepth - depth settings (0-3)
ichorus - 1 for chorus, 0 for vibrato.
***************************/
opcode VChorus,a,akp
asig,ks,ichorus xin
kdep[] fillarray 0,0.45,0.66,1
kset = (ks < 0 ? 0 : (ks > 3 ? 3 : ks))
adel oscili 1.1*kdep[ks],6.87,2
amix vdelay asig,adel,2
xout amix + asig*ichorus
endop
The functionality in these UDOs can be implemented in instruments in a variety
of ways. The typical use will be to have one single-instance instrument running the
tonewheel, mixer and vibrato/chorus elements, and a minimal instrument (instr
1) calling the note mechanism. We could make it a MIDI-controlled instrument,
since this can be very useful in live performance. An example of this is shown in
listing 12.26. Here, we set the note range from 24 to 120, and use controllers 11
to 19 for the drawbar levels, 20 for effect depth, and 21 to select vibrato or chorus.
These can easily be adjusted for speciÔ¨Åc set-ups.
Listing 12.26 MIDI-controlled tonewheel organ example
instr 1
Note(notnum()-24)
endin
instr 100
ToneWheel giwheels
kbar[]
init 9
kbar[0] ctrl7 1,11,0,1
kbar[1] ctrl7 1,12,0,1
kbar[2] ctrl7 1,13,0,1
kbar[3] ctrl7 1,14,0,1
kbar[4] ctrl7 1,15,0,1
kbar[5] ctrl7 1,16,0,1
kbar[6] ctrl7 1,17,0,1
kbar[7] ctrl7 1,18,0,1
kbar[8] ctrl7 1,19,0,1
kvib
ctrl7 1,20,0,3
ksel
ctrl7 1,21,0,1
asig Mixer kbar
12.4 Additive Synthesis
249
out
clip(VChorus(asig,kvib,ksel),0,0dbfs)
endin
schedule 100,0,-1
12.4.2 Synthesis by Analysis
In many applications of additive synthesis, the number of partials is too large for us
to manage manually as part of our program code. In these cases, we will need some
external help to automatically detect the frequencies and amplitudes of the target
spectrum, and then pass these to a bank of multiple oscillators. This detection, also
known as spectral analysis, is the centrepiece of a series of techniques that operate
in the frequency domain (i.e. where we manipulate sinusoidal components, rather
than the waveform itself). Additive synthesis is in part a spectral method, and this
aspect will be explored in Chapter 14.
The object of the analysis, as we have already noted, is the frequencies and am-
plitudes of partials. We can make ‚Äòone-shot‚Äô analyses, where we target a speciÔ¨Åc
point in time of the target sound, or we can take frames at regular intervals to reveal
the evolution of its spectrum. In the Ô¨Årst case, we will have a ‚Äòfrozen‚Äô moment in
time, which can be useful for certain applications. More generally, we will be inter-
ested in the time-varying nature of sounds, so a series of analyses spaced in time are
best suited for this. Managing the huge amounts of data produced by such processes
is often a problem. We can take two approaches:
1. ofÔ¨Çine analysis: in this case we record the waveform of the target sound to a
Ô¨Åle, and apply the analysis to it, storing the results in another Ô¨Åle. The synthesis
process will then read the data from the Ô¨Åle (Fig. 12.15).
2. streaming: here we buffer an input audio stream, analyse it and generate a se-
quence of analysis frames containing its amplitudes and frequencies. This data
can optionally be saved to a Ô¨Åle for later use. This is more demanding compu-
tationally, as both the analysis and synthesis are happening at the same time.
Also, due to the nature of Fourier-based methods, a small amount of inherent la-
tency will exist between input and output because of the buffering involved (Fig.
12.16).
Csound supports both approaches. Traditionally the Ô¨Årst kind of analysis-synthesis
was the only form available, but with the development of new techniques and more
powerful computing platforms, streaming methods were made possible. For this
reason, we will concentrate our discussion on examining this approach.
The Ô¨Årst issue to be resolved when dealing with spectral streams is where to
place the analysis data for easy access by oscillators. As in the tonewheel case, we
can use arrays to hold frequencies and amplitudes. Alternatively, we can employ
function tables for this purpose. Since both are more or less equivalent, we will use
the latter method, for the sake of variety. Before we look into how to obtain the
250
12 Classic Synthesis
ofÔ¨Çine
performance
soundÔ¨Åle
?
analysis
?
analysis Ô¨Åle
?
additive synthesis
analysis Ô¨Åle
?
sound
Fig. 12.15 OfÔ¨Çine analysis-synthesis
input
?
streaming analysis
?
additive synthesis
?
sound
Fig. 12.16 Streaming analysis-synthesis
analysis data, we can design the synthesis process. As with any additive synthesis
method, the sources are sinusoidal oscillators. We can build a bank of these, again
using recursion. Each partial will take its parameter data from a speciÔ¨Åc position in
two tables, which store amplitude and frequency values, respectively. The code for
an oscillator bank UDO is shown in listing 12.27. The opcode has a pitch control,
which can be used to transpose the output sound.
Listing 12.27 An oscillator bank UDO
/*****************************
asig OscBnk kpitch,ifa,ifn,isize
kpitch - pitch transposition factor
ifa - amplitude function table
iff - frequency function table
isize - oscillator bank size
*******************************/
opcode OscBnk,a,kiiio
kp,ifa,iff,is,icnt xin
if icnt < is-1 then
asig OscBnk kp,ifa,iff,is,icnt+1
12.4 Additive Synthesis
251
endif
xout asig +
oscili(port(table(k(icnt),ifa),0.01),
kp*table(k(icnt),iff))
endop
The oscillator bank design is general enough to work in different scenarios. All
it assumes is that a certain number of oscillators are required, and that amplitude
and frequency values for each oscillator will be found sequentially in two tables,
from 0 to the size of the bank -1. We can use different methods to supply this data to
it. A simple way that involves no analysis is to draw a given shape for the spectral
envelope (the shape formed by the amplitude of the partials across the frequency
bands), and decide what speciÔ¨Åc partial frequencies we want. This of course will
be difÔ¨Åcult to manage for time-varying spectra, and so we can get the data from an
analysis process instead.
A common way of Ô¨Ånding amplitudes and frequencies for a given input is through
the phase vocoder. This is a variation on the original channel vocoder discussed in
Section 12.2, which follows the same overall principle of breaking the spectrum into
a number of bands. Here, however, the analysis is more precise in that it provides
both the energy at that band (amplitude) and the frequency for a sinusoidal wave
to reproduce it. While we will leave the detailed discussion of the phase vocoder
until Chapter 14, we will outline here its relevant parameters for additive synthesis
applications.
The analysis breaks the total spectrum into equal-bandwidth portions (as opposed
to equal-Q bands seen in the channel vocoder implementation). The width of each
‚Äòchannel‚Äô is therefore dependent on the number of these, which is determined by the
size of the analysis frame. The phase vocoder takes a number of waveform samples
(the frame), and outputs amplitudes and frequencies representing these. The number
of bands is equivalent to half the analysis size (plus one extra, which we can ignore
for the moment). For example, if we analyse 1024 waveform samples, we get 512
bands.
For efÔ¨Åciency reasons, using power-of-two size is recommended (a fast algo-
rithm, optimised for these lengths is then used). The width of the channels is sim-
ply calculated by dividing the total frequency span (0 Hz to Nyquist frequency) by
the number of bands. For instance, at 44,100 Hz sampling rate, with a frame of
N = 1,024 samples we have 512 channels of 22050
512 = 43.0664 Hz. The analysis is
performed at regular periods, which can vary from 1 to N
4 samples. This is called
the analysis hopsize; more frequent analyses require more computation, but can im-
prove quality.
In Csound, the opcode used for streaming phase vocoder analysis is pvsanal.
The process it employs will be discussed in detail in Chapter 14, but we will dis-
cuss its key principles here. It takes an input signal, the analysis size, the hopsize,
the analysis window (generally the same as the analysis size) and a window shape
(an envelope shape used to smooth the analysis process). It produces a frequency-
domain output using the f-sig data type containing the analysis frame consisting of
amplitudes and frequencies for each band. These can be placed into tables using
252
12 Classic Synthesis
the pvsftw opcode, which returns a Ô¨Çag indicating whether new analysis data was
written to the tables. This is useful because the analysis will not necessarily happen
at every k-cycle. With these opcodes, we can construct an analysis UDO to work
with our oscillator bank. This is shown in listing 12.28.
Listing 12.28 A streaming frequency analysis UDO
/****************************
kflag StreamAnal asig,ifa,iff,isize
asig - input signal
ifa - amplitude function table
iff - frequency function table
isize - number of amp/freq pairs
*****************************/
opcode StreamAnal,k,aiii
asig,ifa,iff,is xin
fsig pvsanal asig,is*2,is/4,is*2,1
xout pvsftw(fsig,ifa,iff)
endop
An example instrument applying these principles is shown in listing 12.29. Here,
we obtain a target spectrum from a soundÔ¨Åle, and use two oscillator banks to resyn-
thesise it with different pitch transpositions.
Listing 12.29 A streaming frequency analysis UDO
gioscs init 512
gifn1 ftgen 1,0,gioscs,7,0,gioscs,0
gifn2 ftgen 2,0,gioscs,7,0,gioscs,0
instr 1
a1 diskin2 "fox.wav",1,0,1
kfl StreamAnal a1,1,2,gioscs
a1 OscBnk p4,1,2,gioscs
a2 OscBnk p5,1,2,gioscs
out (a1+a2)/2
endin
schedule(1,0,10,1,.75)
Various other types of transformations can be applied to the spectral data be-
fore resynthesis. For instance, we could shape the spectral envelope in different
ways, making Ô¨Åltering effects. The frequency data can be modiÔ¨Åed to create inhar-
monic spectra. Two different sounds can have their amplitude and frequency data
exchanged or interpolated to create crossed and morphed timbres. In all of these
cases, we are venturing into the terrain of spectral processing, which will be fol-
lowed up in Chapter 14.
12.5 Conclusions
253
12.5 Conclusions
In this chapter, we explored the three classic types of sound synthesis: source-
modiÔ¨Åer (also known as subtractive), distortion and additive methods. We started by
discussing some fundamentals of the spectral representation of audio, introducing
the concept of sinusoidal components, harmonics and inharmonic partials. These
form an important part of the theory of acoustics that underpins all classic sound
synthesis approaches.
Source-modiÔ¨Åer synthesis was discussed from the perspective of its elements:
the different possibilities of sound generators, and the various types of Ô¨Ålters that
can be applied to them. The section was completed by two design studies: a virtual
analogue model of a synthesiser, and the channel vocoder. In the distortion synthesis
section, we explored in detail a variety of synthesis algorithms, their mathematical
expressions and corresponding Csound code.
Completing the chapter, an overview of additive synthesis was provided, fol-
lowed by a complete tonewheel organ model, and an introduction to analysis-
synthesis techniques. This provides a point of contact with a number of advanced
signal processing methods based on frequency-domain manipulation, which can
provide a rich source of interesting instrument designs. We will be complementing
this with Chapter 14 dedicated to spectral processing.
