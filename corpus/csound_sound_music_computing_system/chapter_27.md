# 4. PVS TRACKS: this sub type carries partial track data, rather than a ﬁxed set of

4. PVS TRACKS: this sub type carries partial track data, rather than a ﬁxed set of
analysis bands. This data contains amplitude, frequency and phase information,
as well as an ID, which can be used to identify a given track. The ordering is
by creation (‘birth’) time, and frequency (in the case of tracks that started at the
same time). Tracks are terminated if no continuation is found, so frame sizes can
vary with time.
As mentioned before, f-sigs run at their own update rate, which is independent
of the instrument control frequency. In order to implement this, spectral signals
carry a frame index that indicates the analysis time, so that opcodes are notiﬁed
if a new frame is ready for processing. Data is produced every analysis time point,
which is spaced by hopsize samples. If this spacing is smaller than ksmps, more than
one analysis will be have to performed in a single k-cycle. In some cases, this will
trigger the use of a sliding algorithm. In other situations, when no such processing
is available, an error message will be issued. The special sliding algorithm is in
general very processor-intensive and might not be suitable for real-time operations.
As a rule of thumb, we should try to keep the hopsize larger than ksmps.
Usage
Frequency-domain signals of the amplitude/frequency subtype can be generated
from an analysis of an input signal (eg. with pvsanal), a table (pvstanal) or by
reading a sequence of pre-analysed frames from a ﬁle (pvsfread):
fsig pvsanal asig,ifsize,ihopsize,iwsize,iwin
fsig pvstanal ktimescal, kamp, kpitch, ktab,
[kdetect, kwrap, ioffset,ifftsize, ihop, idbthresh]
fsig pvsfread ktime, Sname
Analysis will normally require the frame, hop, and window sizes, as the window
type, to be given as i-time parameters. For ﬁle reading, we will require a k-rate time
position from which the current frame is to be read from, and a ﬁle name. Empty
f-sigs can also be created/initialised with pvsinit:
96
4 Advanced Data Types
fsig
pvsinit
ifsize[,ihopsize,iwsize,iwin,iformat]
where the iformat code is 0 for amplitude-frequency, 1 for amplitude-phase, 2 for
complex and 3 for tracks.
Amplitude-frequency frequency-domain signals can be resynthesised using phase
vocoder synthesis (pvsynth) or using additive methods (pvsadsyn):
asig pvsynth fsig
ares pvsadsyn fsrc, inoscs, kfscal
Since an f-sig is self-describing, phase vocoder analysis does not require any
parameters in addition to its input. With additive synthesis, we can determine the
number of bands being resynthesised and use a frequency scaling (transposition)
control. Many processing opcodes can be used between the analysis and synthesis
stages. Listing 4.3 shows a simple example of a frequency shifter, which moves each
analysis component above 300 Hz by 400 Hz.
Listing 4.3 Amplitude-frequency f-sig processing example
instr 1
asig
in
fs1 pvsanal asig,2048,256,2048,1
fs2 pvshift fs1,p4,p5
ahr pvsynth fs2
out ahr
endin
schedule(1,0,1,300,400)
Track data f-sigs are generated by the partials opcode from amplitude-
frequency and amplitude-phase signals, and can be further processed and resyn-
thesised using a variety of methods. Details of spectral (frequency-domain) signal
processing will be further discussed in Chapter 14.
4.3.2 w-sig Variables
In addition to f-sigs, Csound includes a non-standard frequency-domain type, the
w-sig, which carries constant-Q, exponentially-spaced frequency-domain data. This
signal is obtained with the spectrum opcode, and can be used in a number of
analysis operations, for pitch and onset detection, display and spectral histogram.
These signals are not currently used for any audio processing, and there are no
resynthesis methods available for them at the moment.
4.4 Arrays
97
4.4 Arrays
Arrays are a homogeneous set of signals where each member of the set is accessed
by its index number. Arrays can be of any type, such as “an array of k-vars” or “an
array of a-vars”. They may also be multi-dimensional, holding rows and columns,
in the case of two dimensions. The number of indices needed to select an element
in an array determines its dimension.
Arrays can be used to pass around a group of signals. For example, an a-array
may be used to pass around sets of audio signals. The audio signal array can then
be thought of as a multichannel signal. They can also be used to hold vectors or
matrices of numbers, at i-time or k-time, for various applications. In addition, it is
possible to create arrays of strings and f-sigs.
Array types have their own syntax for initialisation, setting and read access,
which is slightly different from that of ordinary variables.
4.4.1 Initialisation
An array is created and initialised using the init opcode:
asigs[] init 4
This creates a one-dimensional array of a-type signals. The variable is declared
on its ﬁrst use as an array using square brackets (i.e. []). The type of the array is
speciﬁed using the same convention as other variables, by looking at the ﬁrst letter
of the variable name:
asigs[][] init 4, 4
This creates a two-dimensional array of a-type signals. It has sizes of four (rows)
and four (columns), and there are 16 elements within the array (4×4 = 16).
Note that the name of the variable is asigs and not asigs[]. The brackets are
used to declare the type, but are not part of the name. After declaring the variable,
subsequent uses of the variable will refer to only the name.
Creating an array and initialising it to a set of values can be verbose, especially
when there are a large number of values to set in the array. An alternative for i-
time and k-rate arrays is to use the fillarray opcode. In the following example,
fillarray is used to create a one-dimensional, ﬁve-element array with values 0,
1, 2, 3 and 4. The resulting value is assigned to the ivals variable. As this is the
ﬁrst time ivals is used, the brackets are necessary to declare the variable’s type.
Subsequent uses only require the variable’s name:
ivals[] fillarray 0, 1, 2, 3, 4
print lenarray(ivals)
The fillarray opcode can be used to initialise arrays after their creation as
well:
98
4 Advanced Data Types
kArr[] init 5
kArr fillarray 0, 1, 2, 3, 4
In this case, we will also be able to use it to initialise two-dimensional arrays.
This is done in row-column order. For instance, a 2×2 matrix such as
!
1 2
3 4
"
can be created with the following code:
iArr[][] init 2,2
iArr fillarray 1,2,3,4
4.4.2 Setting Values
To set values within an array, use the name of the array, followed by square brackets,
and an index. You will need to use one index per dimension, and must use the same
number of square brackets as there are dimensions for the array.
ivals[]
init 4
ivals2[][]
init 4, 4
ivals[0]
= 1
ivals[1]
= 2
ivals2[0][0] = 1
ivals2[0][1] = 2
In the above example, ivals is initialised as a one-dimensional array with size
four. ivals2 is initialised as a two-dimensional array with sizes four and four. By
default, values within a newly initialised array are set to their default empty value.
For example, i- and k-types default to 0, a-types default to a vector of 0’s, strings
default to empty strings ("") and so on.
Following initialisation, the ﬁrst element of ivals is set to 1, and the second
element is set to 2. The element number is determined by the index value given
within the square brackets. Indexes are zero-based, meaning the ﬁrst element is at
index 0, and the last index is at size -1 (in this case, 3). For ivals2, the values of
the ﬁrst and second elements in the ﬁrst group of elements are also set to 1 and 2.
Indexes for arrays may be constant numbers, but may also be expressions. In the
following example, the variable indx is used to set the values 1 and 2 for the ﬁrst
two elements of the array:
ivals[] init 4
indx = 0
ivals[indx] = 1
ivals[indx+1] = 2
4.4 Arrays
99
The use of expressions for indexes is useful for programmatically setting values
within an array, using programming constructs such as branching and loops. These
will be introduced and discussed in Chapter 5.
4.4.3 Reading Values
Reading values from an array uses the same syntax as setting values in an array. As
when writing of values, indexes for the array may be expressions. The following
example prints out the value for each member of the ivals array:
ivals[] fillarray 1,2
print ivals[0]
print ivals[1]
4.4.4 Performance Time
As usual, i-time arrays are only executed at i-time, and thus their index will not
change at performance time (e.g. a k-rate variable or expression for an i-time array
will not force a reading/writing operation to take place). If we require arrays to be
read/set, and indexes to change during performance, we need to use a k-rate array.
It is important to note that even if the array contents do not change, but the indexing
does, then an i-time array is not suitable. This is because indexing and unpacking
(extracting the array value) are i-time operations.
Listing 4.4 k-rate array access example
instr 1
kvals[] init 3
kndx init 0
kvals[0] = 1
kvals[1] = 2
kvals[2] = 3
printk2 kvals[kndx]
kndx = (kndx + 1) % lenarray(kvals)
endin
schedule(1,0,.1)
100
4 Advanced Data Types
4.4.5 String and f-sig Arrays
As indicated above, arrays of strings can be created and manipulated. These allow
indexing at initialisation and performance time, allowing which member is accessed
to change from one k-cycle to another.
Listing 4.5 String array example
instr 1
Svals[] init 2
kval init 0
Svals[0] = "hello"
Svals[1] = "world"
kval = kval % 2
puts Svals[kval],kval+1
kval +=1
endin
schedule(1,0,2/kr)
Similarly, f-sig arrays are also possible, and as they are a performance-time vari-
able type, indexing at k-rate is allowed.
4.4.6 Arithmetic Expressions
Numeric arrays with scalar elements (i-time and k-rate) can also be combined di-
rectly into expressions using other arrays, scalar variables or constants. These can
include addition (+), subtraction (-), multiplication (*), division (/) and exponentia-
tion (ˆ). The following example demonstrates this facility.
Listing 4.6 Arrays in arithmetic expressions
instr 1
iArr[] fillarray 1,2,3
iRes[] = (iArr * iArr) / 2
print iRes[0]
print iRes[1]
print iRes[2]
endin
schedule(1,0,0)
Running this program, we will obtain the following printout at the console:
SECTION 1:
new alloc for instr 1:
instr 1:
#i2 = 0.500
instr 1:
#i3 = 2.000
instr 1:
#i4 = 4.500
4.4 Arrays
101
Note that this is not extended to all types. Arrays of audio vectors (a-type) and
f-sigs cannot be combined in this way, instead each member must be accessed sep-
arately via indexing:
nchnls = 2
instr 1
aout[] init 2
aout[0] diskin "fox.wav"
aout[1] diskin "beats.wav"
aout[0] = aout[0]*0.5
aout[1] = aout[1]*0.5
out aout
endin
Also note that the shorthand expressions +=, *= etc. are not deﬁned for use
with arrays. In this case, we need to write them in full, as in the example above
(aout[0] = aout[0]*0.5).
4.4.7 Arrays and Function tables
Function tables can be considered as one-dimensional numeric arrays, that have
global scope. It is possible to copy data from i-time and k-rate array variables into
tables and vice versa. In the following example, we copy the contents of a function
table into an array.
Listing 4.7 Copying the contents of a function table into an array
gifn ftgen 1,0,4,-2,1,2,3,4
instr 1
iArr[] init ftlen(gifn)
copyf2array iArr,gifn
print iArr[0]
print iArr[1]
print iArr[2]
print iArr[3]
endin
schedule(1,0,0)
Likewise, an array can be copied into a function table.
Listing 4.8 Copying the contents of an array into a function table
giArr[] fillarray 1,2,3,4
instr 1
ifn ftgen 0,0,lenarray(giArr),2,0
copya2ftab giArr,ifn
print table(0,ifn)
102
4 Advanced Data Types
print table(1,ifn)
print table(2,ifn)
print table(3,ifn)
endin
schedule(1,0,0)
The interchangeability between the array and function table representations is
explored by some opcodes. For instance, the standard oscillators (oscil, oscili,
oscil3) can read from an i-time array instead of a table.
Listing 4.9 Using an array in place of a function table
instr 1
iArr[] fillarray p6,p7,p8,p9
amod oscil 1,2,iArr
aout oscili p4,p5*amod
out aout
endin
schedule(1,0,2,0dbfs/2,440,1,2,1.5,1.25)
schedule(1,2,2,0dbfs/2,440,1,1.5,2,1.25)
schedule(1,4,2,0dbfs/2,440,1,1.5,1.25,2)
schedule(1,6,2,0dbfs/2,440,1,1.25,1.5,2)
In this case, a simple arpeggiator is easily created by using a local array as the
source for an oscillator, with varying patterns. Note that these opcodes have the
restriction that array lengths are required to be a power-of-two value.
4.4.8 Audio Arrays
A useful application of audio arrays is to handle stereo and multichannel signals.
In particular, diskin or diskin2 can write to arrays, which can then be passed
directly to the output, as the opcode out can handle multiple channels held in an
array:
nchnls=2
instr 1
aout[] diskin2 "stereo.wav"
out aout
endin
Arrays can also be used to hold various signals that will be mixed together, or fur-
ther processed. In the next example, an a-sig array is initialised with one dimension
of three members. Three vco2 oscillators are then used to write signals into each of
the array member slots. Next their values are summed into the aout variable. The
resulting signal is then sent to the out opcode.
4.5 Conclusions
103
Listing 4.10 Audio arrays handling multiple sources
instr 1
asigs[] init 3
asigs[0] = vco2(p4, p5)
asigs[1] = vco2(p4, p6)
asigs[2] = vco2(p4, p7)
aout = asigs[0] + asigs[1] + asigs[2]
out aout
endin
schedule(1,0,1,0dbfs/6,440,660,880)
In real-world Csound usage, we would likely use a loop to iterate over the array
(which can be of varying length in that case) and the array signal source would also
be separate from the processing code. For example, a source may be the diskin
opcode, reading in multichannel audio ﬁles, and the array-processing code may be
contained in a user-deﬁned opcode (see Chapter 7).
4.5 Conclusions
This chapter explored advanced data types in Csound. Strings represent textual
data, useful for creating diagnostic messages and ﬁle paths. Spectral-domain sig-
nals provide frequency-domain representations of audio signals, and present many
new kinds of processing methods to the user. Finally, arrays provide ways of work-
ing with sets of ordered, homogenous data, simplifying the handling and processing
of data meant to be processed together.
The data types discussed here open up a great number of options that were not
available in the early versions of Csound. In particular, as will be explained in chap-
ter 5, arrays enable a high level of programmability that goes hand in hand with
control-ﬂow constructs, allowing code to be made more concise and elegant. They
can also be used as containers for vector and matrix operations (such as windowing
and Fourier transforms) that will be very useful in a variety of sound and music
computing applications.